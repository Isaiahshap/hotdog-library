{"version":3,"file":"asyncLock.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/asyncLock.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,SAAS;IAAtB;QACY,sBAAiB,GAAkB,OAAO,CAAC,OAAO,EAAE,CAAC;IAuDjE,CAAC;IArDG;;;;;OAKG;IACI,SAAS,CAAI,IAA0B,EAAE,MAAoB;QAChE,MAAM,EAAE,cAAc,EAAE,CAAC;QAEzB,MAAM,WAAW,GAAG,MAAM;YACtB,CAAC,CAAC,GAAG,EAAE;gBACD,MAAM,CAAC,cAAc,EAAE,CAAC;gBACxB,OAAO,IAAI,EAAE,CAAC;YAClB,CAAC;YACH,CAAC,CAAC,IAAI,CAAC;QAEX,MAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9D,oKAAoK;QACpK,IAAI,CAAC,iBAAiB,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;QACrG,OAAO,YAAY,CAAC;IACxB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAI,IAA0B,EAAE,KAAkB,EAAE,MAAoB;QACjG,MAAM,EAAE,cAAc,EAAE,CAAC;QAEzB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACpB,OAAO,MAAM,IAAI,EAAE,CAAC;SACvB;QAED,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAK,CAAC;QACnC,IAAI,aAAa,GAAG,CAAC,CAAC;QAEtB,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,CACnB,IAAI;aACC,SAAS,CAAC,KAAK,IAAI,EAAE;YAClB,aAAa,EAAE,CAAC;YAChB,IAAI,aAAa,KAAK,KAAK,CAAC,MAAM,EAAE;gBAChC,QAAQ,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;aAClC;YACD,OAAO,QAAQ,CAAC,OAAO,CAAC;QAC5B,CAAC,EAAE,MAAM,CAAC;aACT,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CACxC,CAAC;QAEF,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC5B,CAAC;CACJ","sourcesContent":["import { Deferred } from \"./deferred\";\r\n\r\n/**\r\n * Provides a simple way of creating the rough equivalent of an async critical section.\r\n *\r\n * @example\r\n * ```typescript\r\n * const myLock = new AsyncLock();\r\n *\r\n * private async MyFuncAsync(): Promise<void> {\r\n *   await myLock.lockAsync(async () => {\r\n *     await operation1Async();\r\n *     await operation2Async();\r\n *   });\r\n * }\r\n * ```\r\n */\r\nexport class AsyncLock {\r\n    private _currentOperation: Promise<void> = Promise.resolve();\r\n\r\n    /**\r\n     * Executes the provided function when the lock is acquired (e.g. when the previous operation finishes).\r\n     * @param func The function to execute.\r\n     * @param signal An optional signal that can be used to abort the operation.\r\n     * @returns A promise that resolves when the func finishes executing.\r\n     */\r\n    public lockAsync<T>(func: () => T | Promise<T>, signal?: AbortSignal): Promise<T> {\r\n        signal?.throwIfAborted();\r\n\r\n        const wrappedFunc = signal\r\n            ? () => {\r\n                  signal.throwIfAborted();\r\n                  return func();\r\n              }\r\n            : func;\r\n\r\n        const newOperation = this._currentOperation.then(wrappedFunc);\r\n        // NOTE: It would be simpler to just hold a Promise<unknown>, but this class should not prevent an object held by the returned promise from being garbage collected.\r\n        this._currentOperation = new Promise<void>((resolve) => newOperation.then(() => resolve(), resolve));\r\n        return newOperation;\r\n    }\r\n\r\n    /**\r\n     * Executes the provided function when all the specified locks are acquired.\r\n     * @param func The function to execute.\r\n     * @param locks The locks to acquire.\r\n     * @param signal An optional signal that can be used to abort the operation.\r\n     * @returns A promise that resolves when the func finishes executing.\r\n     */\r\n    public static async LockAsync<T>(func: () => T | Promise<T>, locks: AsyncLock[], signal?: AbortSignal): Promise<T> {\r\n        signal?.throwIfAborted();\r\n\r\n        if (locks.length === 0) {\r\n            return await func();\r\n        }\r\n\r\n        const deferred = new Deferred<T>();\r\n        let acquiredLocks = 0;\r\n\r\n        locks.forEach((lock) =>\r\n            lock\r\n                .lockAsync(async () => {\r\n                    acquiredLocks++;\r\n                    if (acquiredLocks === locks.length) {\r\n                        deferred.resolve(await func());\r\n                    }\r\n                    return deferred.promise;\r\n                }, signal)\r\n                .catch((e) => deferred.reject(e))\r\n        );\r\n\r\n        return deferred.promise;\r\n    }\r\n}\r\n"]}