{"version":3,"file":"decorators.serialization.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/decorators.serialization.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,WAAW,EAAE,MAAM,YAAY,CAAC;AAMzC,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,qBAAqB,CAAC;AACrD,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAC;AAE5E,OAAO,EAAE,cAAc,EAAE,MAAM,wBAAwB,CAAC;AAWxD,MAAM,WAAW,GAAG,UAAa,gBAAyB,EAAE,MAAS,EAAE,WAAoB,EAAE,UAA6B,EAAE;IACxH,MAAM,WAAW,GAAG,gBAAgB,EAAE,CAAC;IAEvC,OAAO;IACP,IAAI,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAC9B,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;KAC3D;IAED,MAAM,UAAU,GAAG,cAAc,CAAC,WAAW,CAAC,CAAC;IAE/C,0DAA0D;IAC1D,MAAM,UAAU,GAAwB,EAAE,CAAC;IAE3C,aAAa;IACb,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE;QAC/B,MAAM,kBAAkB,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;QAChD,MAAM,cAAc,GAAS,MAAO,CAAC,QAAQ,CAAC,CAAC;QAC/C,MAAM,YAAY,GAAG,kBAAkB,CAAC,IAAI,CAAC;QAE7C,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,KAAK,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,IAAI,mBAAmB,CAAC,oBAAoB,CAAC,EAAE;YAClI,QAAQ,YAAY,EAAE;gBAClB,KAAK,CAAC,CAAC,CAAC,QAAQ;gBAChB,KAAK,CAAC,CAAC,CAAC,iBAAiB;gBACzB,KAAK,EAAE,EAAE,mBAAmB;oBAClB,WAAY,CAAC,QAAQ,CAAC,GAAG,cAAc,CAAC;oBAC9C,MAAM;gBACV,KAAK,CAAC,EAAE,UAAU;oBACd,IAAI,OAAO,CAAC,qBAAqB,IAAI,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;wBAChE,WAAY,CAAC,QAAQ,CAAC,GAAG,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;qBACtE;yBAAM;wBACG,WAAY,CAAC,QAAQ,CAAC,GAAG,WAAW,IAAI,cAAc,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;wBACtH,UAAU,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAS,WAAY,CAAC,QAAQ,CAAC,CAAC;qBACtE;oBACD,MAAM;gBACV,KAAK,CAAC,CAAC,CAAC,SAAS;gBACjB,KAAK,CAAC,CAAC,CAAC,oBAAoB;gBAC5B,KAAK,CAAC,CAAC,CAAC,UAAU;gBAClB,KAAK,CAAC,CAAC,CAAC,UAAU;gBAClB,KAAK,CAAC,CAAC,CAAC,eAAe;gBACvB,KAAK,EAAE,CAAC,CAAC,aAAa;gBACtB,KAAK,EAAE,EAAE,SAAS;oBACR,WAAY,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;oBACrF,MAAM;aACb;SACJ;KACJ;IAED,OAAO,WAAW,CAAC;AACvB,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,OAAO,mBAAmB;IAkC5B;;;;OAIG;IACI,MAAM,CAAC,0BAA0B,CAAC,MAAmB,EAAE,WAAgB;QAC1E,IAAI,MAAM,CAAC,UAAU,EAAE;YACnB,WAAW,CAAC,UAAU,GAAG,EAAE,CAAC;YAC5B,KAAK,IAAI,cAAc,GAAG,CAAC,EAAE,cAAc,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,cAAc,EAAE,EAAE;gBACtF,MAAM,SAAS,GAAG,MAAM,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;gBAEpD,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,CAAC,CAAC;aACtD;SACJ;IACL,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,SAAS,CAAI,MAAS,EAAE,mBAAyB;QAC3D,IAAI,CAAC,mBAAmB,EAAE;YACtB,mBAAmB,GAAG,EAAE,CAAC;SAC5B;QAED,OAAO;QACP,IAAI,IAAI,EAAE;YACN,mBAAmB,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SACnD;QAED,MAAM,oBAAoB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;QAEpD,aAAa;QACb,KAAK,MAAM,QAAQ,IAAI,oBAAoB,EAAE;YACzC,MAAM,kBAAkB,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC;YAC1D,MAAM,kBAAkB,GAAG,kBAAkB,CAAC,UAAU,IAAI,QAAQ,CAAC;YACrE,MAAM,YAAY,GAAG,kBAAkB,CAAC,IAAI,CAAC;YAC7C,MAAM,cAAc,GAAS,MAAO,CAAC,QAAQ,CAAC,CAAC;YAE/C,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,KAAK,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,IAAI,mBAAmB,CAAC,oBAAoB,CAAC,EAAE;gBAClI,QAAQ,YAAY,EAAE;oBAClB,KAAK,CAAC,EAAE,QAAQ;wBACZ,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC;wBACzD,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,SAAS,EAAE,CAAC;wBACrE,MAAM;oBACV,KAAK,CAAC,EAAE,SAAS;wBACb,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;wBACnE,MAAM;oBACV,KAAK,CAAC,EAAE,oBAAoB;wBACxB,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,SAAS,EAAE,CAAC;wBACrE,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;wBACnE,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,OAAO,EAAE,CAAC;wBACnE,MAAM;oBACV,KAAK,CAAC,EAAE,iBAAiB;wBACrB,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,EAAE,CAAC;wBAC5D,MAAM;oBACV,KAAK,CAAC,EAAE,eAAe;wBACnB,mBAAmB,CAAC,kBAAkB,CAAC,GAAG,cAAc,CAAC,SAAS,EAAE,CAAC;wBACrE,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,mBAAmB,CAAC,kBAAkB,CAAC,GAAY,cAAe,CAAC,OAAO,EAAE,CAAC;wBAC7E,MAAM;oBACV,KAAK,CAAC,EAAE,mBAAmB;wBACvB,mBAAmB,CAAC,kBAAkB,CAAC,GAAkC,cAAe,CAAC,SAAS,EAAE,CAAC;wBACrG,MAAM;oBACV,KAAK,EAAE,EAAE,aAAa;wBAClB,mBAAmB,CAAC,kBAAkB,CAAC,GAAgB,cAAe,CAAC,OAAO,EAAE,CAAC;wBACjF,MAAM;oBACV,KAAK,EAAE,EAAE,mBAAmB;wBACxB,mBAAmB,CAAC,kBAAkB,CAAC,GAAY,cAAe,CAAC,EAAE,CAAC;wBACtE,MAAM;oBACV,KAAK,EAAE,EAAE,SAAS;wBACd,mBAAmB,CAAC,kBAAkB,CAAC,GAAY,cAAe,CAAC,OAAO,EAAE,CAAC;wBAC7E,MAAM;iBACb;aACJ;SACJ;QAED,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,eAAe,CAAC,MAAW,EAAE,WAAgB,EAAE,KAAsB,EAAE,OAAyB;QAC1G,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,GAAG,EAAE,CAAC;SAChB;QAED,MAAM,UAAU,GAAG,cAAc,CAAC,WAAW,CAAC,CAAC;QAE/C,aAAa;QACb,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE;YAC/B,MAAM,kBAAkB,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;YAChD,MAAM,cAAc,GAAG,MAAM,CAAC,kBAAkB,CAAC,UAAU,IAAI,QAAQ,CAAC,CAAC;YACzE,MAAM,YAAY,GAAG,kBAAkB,CAAC,IAAI,CAAC;YAE7C,IAAI,cAAc,KAAK,SAAS,IAAI,cAAc,KAAK,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,IAAI,mBAAmB,CAAC,oBAAoB,CAAC,EAAE;gBAClI,MAAM,IAAI,GAAQ,WAAW,CAAC;gBAC9B,QAAQ,YAAY,EAAE;oBAClB,KAAK,CAAC,EAAE,QAAQ;wBACZ,IAAI,CAAC,QAAQ,CAAC,GAAG,cAAc,CAAC;wBAChC,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,IAAI,KAAK,EAAE;4BACP,IAAI,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC,cAAc,CAAC,cAAc,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;yBACvF;wBACD,MAAM;oBACV,KAAK,CAAC,EAAE,SAAS;wBACb,IAAI,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBAClD,MAAM;oBACV,KAAK,CAAC,EAAE,oBAAoB;wBACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC,wBAAwB,CAAC,cAAc,CAAC,CAAC;wBAC9E,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,IAAI,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBACnD,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,IAAI,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBACnD,MAAM;oBACV,KAAK,CAAC,EAAE,iBAAiB;wBACrB,IAAI,KAAK,EAAE;4BACP,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,eAAe,CAAC,cAAc,CAAC,CAAC;yBAC1D;wBACD,MAAM;oBACV,KAAK,CAAC,EAAE,eAAe;wBACnB,IAAI,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,CAAC;wBACxE,MAAM;oBACV,KAAK,CAAC,EAAE,UAAU;wBACd,IAAI,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBAClD,MAAM;oBACV,KAAK,CAAC,EAAE,mBAAmB;wBACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,mBAAmB,CAAC,mCAAmC,CAAC,cAAc,CAAC,CAAC;wBACzF,MAAM;oBACV,KAAK,EAAE,EAAE,aAAa;wBAClB,IAAI,CAAC,QAAQ,CAAC,GAAG,UAAU,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBACtD,MAAM;oBACV,KAAK,EAAE,EAAE,mBAAmB;wBACxB,IAAI,KAAK,EAAE;4BACP,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;yBACxD;wBACD,MAAM;oBACV,KAAK,EAAE,EAAE,SAAS;wBACd,IAAI,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;wBAClD,MAAM;iBACb;aACJ;SACJ;IACL,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,KAAK,CAAI,gBAAyB,EAAE,MAAW,EAAE,KAAsB,EAAE,UAA4B,IAAI;QACnH,MAAM,WAAW,GAAG,gBAAgB,EAAE,CAAC;QAEvC,OAAO;QACP,IAAI,IAAI,EAAE;YACN,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;SAC5C;QAED,mBAAmB,CAAC,eAAe,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;QAEzE,OAAO,WAAW,CAAC;IACvB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAI,gBAAyB,EAAE,MAAS,EAAE,UAA6B,EAAE;QACxF,OAAO,WAAW,CAAC,gBAAgB,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACjE,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,WAAW,CAAI,gBAAyB,EAAE,MAAS;QAC7D,OAAO,WAAW,CAAC,gBAAgB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;IACvD,CAAC;;AA3OD;;GAEG;AACW,wCAAoB,GAAG,KAAK,CAAC;AAE3C;;GAEG;AACW,uDAAmC,GAAG,CAAC,cAAmB,EAAgC,EAAE;IACtG,MAAM,WAAW,CAAC,8BAA8B,CAAC,CAAC;AACtD,CAAC,CAAC;AAEF;;GAEG;AACW,4CAAwB,GAAG,CAAC,cAAmB,EAAqB,EAAE;IAChF,MAAM,WAAW,CAAC,mBAAmB,CAAC,CAAC;AAC3C,CAAC,CAAC;AAEF;;GAEG;AACW,sCAAkB,GAAG,CAAC,cAAmB,EAAe,EAAE;IACpE,MAAM,WAAW,CAAC,aAAa,CAAC,CAAC;AACrC,CAAC,CAAC;AAEF;;GAEG;AACW,kCAAc,GAAG,CAAC,cAAmB,EAAE,KAAY,EAAE,OAAe,EAAyB,EAAE;IACzG,MAAM,WAAW,CAAC,SAAS,CAAC,CAAC;AACjC,CAAC,CAAC","sourcesContent":["import type { FresnelParameters } from \"../Materials/fresnelParameters\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { _WarnImport } from \"./devTools\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Tags } from \"./tags\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { GetMergedStore } from \"./decorators.functions\";\r\n\r\n/** @internal */\r\nexport interface CopySourceOptions {\r\n    /*\r\n     * if a texture is used in more than one channel (e.g diffuse and opacity),\r\n     * only clone it once and reuse it on the other channels. Default false\r\n     */\r\n    cloneTexturesOnlyOnce?: boolean;\r\n}\r\n\r\nconst _copySource = function <T>(creationFunction: () => T, source: T, instanciate: boolean, options: CopySourceOptions = {}): T {\r\n    const destination = creationFunction();\r\n\r\n    // Tags\r\n    if (Tags && Tags.HasTags(source)) {\r\n        Tags.AddTagsTo(destination, Tags.GetTags(source, true));\r\n    }\r\n\r\n    const classStore = GetMergedStore(destination);\r\n\r\n    // Map from source texture uniqueId to destination texture\r\n    const textureMap: Record<number, any> = {};\r\n\r\n    // Properties\r\n    for (const property in classStore) {\r\n        const propertyDescriptor = classStore[property];\r\n        const sourceProperty = (<any>source)[property];\r\n        const propertyType = propertyDescriptor.type;\r\n\r\n        if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n            switch (propertyType) {\r\n                case 0: // Value\r\n                case 6: // Mesh reference\r\n                case 11: // Camera reference\r\n                    (<any>destination)[property] = sourceProperty;\r\n                    break;\r\n                case 1: // Texture\r\n                    if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\r\n                        (<any>destination)[property] = textureMap[sourceProperty.uniqueId];\r\n                    } else {\r\n                        (<any>destination)[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\r\n                        textureMap[sourceProperty.uniqueId] = (<any>destination)[property];\r\n                    }\r\n                    break;\r\n                case 2: // Color3\r\n                case 3: // FresnelParameters\r\n                case 4: // Vector2\r\n                case 5: // Vector3\r\n                case 7: // Color Curves\r\n                case 10: // Quaternion\r\n                case 12: // Matrix\r\n                    (<any>destination)[property] = instanciate ? sourceProperty : sourceProperty.clone();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return destination;\r\n};\r\n\r\n/**\r\n * Class used to help serialization objects\r\n */\r\nexport class SerializationHelper {\r\n    /**\r\n     * Gets or sets a boolean to indicate if the UniqueId property should be serialized\r\n     */\r\n    public static AllowLoadingUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImageProcessingConfigurationParser = (sourceProperty: any): ImageProcessingConfiguration => {\r\n        throw _WarnImport(\"ImageProcessingConfiguration\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _FresnelParametersParser = (sourceProperty: any): FresnelParameters => {\r\n        throw _WarnImport(\"FresnelParameters\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ColorCurvesParser = (sourceProperty: any): ColorCurves => {\r\n        throw _WarnImport(\"ColorCurves\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _TextureParser = (sourceProperty: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> => {\r\n        throw _WarnImport(\"Texture\");\r\n    };\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        if (source.animations) {\r\n            destination.animations = [];\r\n            for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\r\n                const animation = source.animations[animationIndex];\r\n\r\n                destination.animations.push(animation.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static function used to serialized a specific entity\r\n     * @param entity defines the entity to serialize\r\n     * @param serializationObject defines the optional target object where serialization data will be stored\r\n     * @returns a JSON compatible object representing the serialization of the entity\r\n     */\r\n    public static Serialize<T>(entity: T, serializationObject?: any): any {\r\n        if (!serializationObject) {\r\n            serializationObject = {};\r\n        }\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(entity);\r\n        }\r\n\r\n        const serializedProperties = GetMergedStore(entity);\r\n\r\n        // Properties\r\n        for (const property in serializedProperties) {\r\n            const propertyDescriptor = serializedProperties[property];\r\n            const targetPropertyName = propertyDescriptor.sourceName || property;\r\n            const propertyType = propertyDescriptor.type;\r\n            const sourceProperty = (<any>entity)[property];\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        serializationObject[targetPropertyName] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 2: // Color3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 4: // Vector2\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 5: // Vector3\r\n                        serializationObject[targetPropertyName] = sourceProperty.asArray();\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        serializationObject[targetPropertyName] = sourceProperty.id;\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        serializationObject[targetPropertyName] = sourceProperty.serialize();\r\n                        break;\r\n                    case 8: // Color 4\r\n                        serializationObject[targetPropertyName] = (<Color4>sourceProperty).asArray();\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        serializationObject[targetPropertyName] = (<ImageProcessingConfiguration>sourceProperty).serialize();\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        serializationObject[targetPropertyName] = (<Quaternion>sourceProperty).asArray();\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        serializationObject[targetPropertyName] = (<Camera>sourceProperty).id;\r\n                        break;\r\n                    case 12: // Matrix\r\n                        serializationObject[targetPropertyName] = (<Matrix>sourceProperty).asArray();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\r\n     * @param source the source json data\r\n     * @param destination the destination object\r\n     * @param scene the scene where the object is\r\n     * @param rootUrl root url to use to load assets\r\n     */\r\n    public static ParseProperties(source: any, destination: any, scene: Nullable<Scene>, rootUrl: Nullable<string>) {\r\n        if (!rootUrl) {\r\n            rootUrl = \"\";\r\n        }\r\n\r\n        const classStore = GetMergedStore(destination);\r\n\r\n        // Properties\r\n        for (const property in classStore) {\r\n            const propertyDescriptor = classStore[property];\r\n            const sourceProperty = source[propertyDescriptor.sourceName || property];\r\n            const propertyType = propertyDescriptor.type;\r\n\r\n            if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\r\n                const dest = <any>destination;\r\n                switch (propertyType) {\r\n                    case 0: // Value\r\n                        dest[property] = sourceProperty;\r\n                        break;\r\n                    case 1: // Texture\r\n                        if (scene) {\r\n                            dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\r\n                        }\r\n                        break;\r\n                    case 2: // Color3\r\n                        dest[property] = Color3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 3: // FresnelParameters\r\n                        dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\r\n                        break;\r\n                    case 4: // Vector2\r\n                        dest[property] = Vector2.FromArray(sourceProperty);\r\n                        break;\r\n                    case 5: // Vector3\r\n                        dest[property] = Vector3.FromArray(sourceProperty);\r\n                        break;\r\n                    case 6: // Mesh reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getLastMeshById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 7: // Color Curves\r\n                        dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\r\n                        break;\r\n                    case 8: // Color 4\r\n                        dest[property] = Color4.FromArray(sourceProperty);\r\n                        break;\r\n                    case 9: // Image Processing\r\n                        dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\r\n                        break;\r\n                    case 10: // Quaternion\r\n                        dest[property] = Quaternion.FromArray(sourceProperty);\r\n                        break;\r\n                    case 11: // Camera reference\r\n                        if (scene) {\r\n                            dest[property] = scene.getCameraById(sourceProperty);\r\n                        }\r\n                        break;\r\n                    case 12: // Matrix\r\n                        dest[property] = Matrix.FromArray(sourceProperty);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new entity from a serialization data object\r\n     * @param creationFunction defines a function used to instanciated the new entity\r\n     * @param source defines the source serialization data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url for resources\r\n     * @returns a new entity\r\n     */\r\n    public static Parse<T>(creationFunction: () => T, source: any, scene: Nullable<Scene>, rootUrl: Nullable<string> = null): T {\r\n        const destination = creationFunction();\r\n\r\n        // Tags\r\n        if (Tags) {\r\n            Tags.AddTagsTo(destination, source.tags);\r\n        }\r\n\r\n        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\r\n\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * Clones an object\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @param options defines the options to use\r\n     * @returns the cloned object\r\n     */\r\n    public static Clone<T>(creationFunction: () => T, source: T, options: CopySourceOptions = {}): T {\r\n        return _copySource(creationFunction, source, false, options);\r\n    }\r\n\r\n    /**\r\n     * Instanciates a new object based on a source one (some data will be shared between both object)\r\n     * @param creationFunction defines the function used to instanciate the new object\r\n     * @param source defines the source object\r\n     * @returns the new object\r\n     */\r\n    public static Instanciate<T>(creationFunction: () => T, source: T): T {\r\n        return _copySource(creationFunction, source, true);\r\n    }\r\n}\r\n"]}