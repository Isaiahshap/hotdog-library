{"version":3,"file":"materialHelper.functions.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/materialHelper.functions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Material } from \"./material\";\r\nimport type { Nullable } from \"../types\";\r\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\n// Temps\r\nconst _TempFogColor = Color3.Black();\r\nconst _TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };\r\n\r\n/**\r\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n * @param defines The generated defines used in the effect\r\n * @param effect The effect we are binding the data to\r\n * @param scene The scene we are willing to render with logarithmic scale for\r\n */\r\nexport function BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n        const camera = scene.activeCamera as Camera;\r\n        if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n        }\r\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the fog information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param linearSpace Defines if the fog effect is applied in linear space\r\n */\r\nexport function BindFogParameters(scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace = false): void {\r\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== Constants.FOGMODE_NONE) {\r\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n        // Convert fog color to linear space if used in a linear space computed shader.\r\n        if (linearSpace) {\r\n            scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n            effect.setColor3(\"vFogColor\", _TempFogColor);\r\n        } else {\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param influencers The number of influencers\r\n */\r\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n        const manager = (mesh as Mesh).morphTargetManager;\r\n        if (manager?.isUsingTextureForTargets) {\r\n            return;\r\n        }\r\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n        for (let index = 0; index < influencers; index++) {\r\n            attribs.push(Constants.PositionKind + index);\r\n\r\n            if (normal) {\r\n                attribs.push(Constants.NormalKind + index);\r\n            }\r\n\r\n            if (tangent) {\r\n                attribs.push(Constants.TangentKind + index);\r\n            }\r\n\r\n            if (uv) {\r\n                attribs.push(Constants.UVKind + \"_\" + index);\r\n            }\r\n\r\n            if (attribs.length > maxAttributesCount) {\r\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Add the list of attributes required for instances to the attribs array.\r\n * @param attribs The current list of supported attribs\r\n * @param needsPreviousMatrices If the shader needs previous matrices\r\n */\r\nexport function PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n    attribs.push(\"world0\");\r\n    attribs.push(\"world1\");\r\n    attribs.push(\"world2\");\r\n    attribs.push(\"world3\");\r\n    if (needsPreviousMatrices) {\r\n        attribs.push(\"previousWorld0\");\r\n        attribs.push(\"previousWorld1\");\r\n        attribs.push(\"previousWorld2\");\r\n        attribs.push(\"previousWorld3\");\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the morph targets information from the mesh to the effect.\r\n * @param abstractMesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n */\r\nexport function BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n    const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n    if (!abstractMesh || !manager) {\r\n        return;\r\n    }\r\n\r\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n}\r\n\r\n/**\r\n * Binds the scene's uniform buffer to the effect.\r\n * @param effect defines the effect to bind to the scene uniform buffer\r\n * @param sceneUbo defines the uniform buffer storing scene data\r\n */\r\nexport function BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n    sceneUbo.bindToEffect(effect, \"Scene\");\r\n}\r\n\r\n/**\r\n * Helps preparing the defines values about the UVs in used in the effect.\r\n * UVs are shared as much as we can across channels in the shaders.\r\n * @param texture The texture we are preparing the UVs for\r\n * @param defines The defines to update\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n    defines._needUVs = true;\r\n    defines[key] = true;\r\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n    } else {\r\n        defines[key + \"DIRECTUV\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Binds a texture matrix value to its corresponding uniform\r\n * @param texture The texture to bind the matrix for\r\n * @param uniformBuffer The uniform buffer receiving the data\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n    const matrix = texture.getTextureMatrix();\r\n\r\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare for baked vertex animations\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n    if (enabled) {\r\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n    }\r\n}\r\n\r\n// Copies the bones transformation matrices into the target array and returns the target's reference\r\nfunction _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n    target.set(source);\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Binds the bones information from the mesh to the effect.\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n */\r\nexport function BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n    if (!effect || !mesh) {\r\n        return;\r\n    }\r\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n        mesh.computeBonesUsingShaders = false;\r\n    }\r\n\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        const skeleton = mesh.skeleton;\r\n\r\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n            effect.setTexture(\"boneSampler\", boneTexture);\r\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n        } else {\r\n            const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n            if (matrices) {\r\n                effect.setMatrices(\"mBones\", matrices);\r\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                    }\r\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the light information to the effect.\r\n * @param light The light containing the generator\r\n * @param effect The effect we are binding the data to\r\n * @param lightIndex The light index in the effect used to render\r\n */\r\nexport function BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n    light.transferToEffect(effect, lightIndex + \"\");\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param light Light to bind\r\n * @param lightIndex Light index\r\n * @param scene The scene where the light belongs to\r\n * @param effect The effect we are binding the data to\r\n * @param useSpecular Defines if specular is supported\r\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n */\r\nexport function BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param defines The generated defines for the effect\r\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n */\r\nexport function BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const light = mesh.lightSources[i];\r\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for bones according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the bones attributes for\r\n * @param defines The current Defines of the effect\r\n * @param fallbacks The current effect fallback strategy\r\n */\r\nexport function PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n        fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n        attribs.push(Constants.MatricesIndicesKind);\r\n        attribs.push(Constants.MatricesWeightsKind);\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n            attribs.push(Constants.MatricesIndicesExtraKind);\r\n            attribs.push(Constants.MatricesWeightsExtraKind);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check and prepare the list of attributes required for instances according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param defines The current MaterialDefines of the effect\r\n */\r\nexport function PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n    }\r\n\r\n    if (defines.INSTANCESCOLOR) {\r\n        attribs.push(Constants.ColorInstanceKind);\r\n    }\r\n}\r\n\r\n/**\r\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n * @param defines The defines to update while falling back\r\n * @param fallbacks The authorized effect fallbacks\r\n * @param maxSimultaneousLights The maximum number of lights allowed\r\n * @param rank the current rank of the Effect\r\n * @returns The newly affected rank\r\n */\r\nexport function HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n    let lightFallbackRank = 0;\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n\r\n        if (lightIndex > 0) {\r\n            lightFallbackRank = rank + lightIndex;\r\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n        }\r\n\r\n        if (!defines[\"SHADOWS\"]) {\r\n            if (defines[\"SHADOW\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n            }\r\n        }\r\n    }\r\n    return lightFallbackRank++;\r\n}\r\n\r\n/**\r\n * Gets the current status of the fog (should it be enabled?)\r\n * @param mesh defines the mesh to evaluate for fog support\r\n * @param scene defines the hosting scene\r\n * @returns true if fog must be enabled\r\n */\r\nexport function GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Constants.FOGMODE_NONE;\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n * @param mesh defines the current mesh\r\n * @param scene defines the current scene\r\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n * @param pointsCloud defines if point cloud rendering has to be turned on\r\n * @param fogEnabled defines if fog has to be turned on\r\n * @param alphaTest defines if alpha testing has to be turned on\r\n * @param defines defines the current list of defines\r\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n */\r\nexport function PrepareDefinesForMisc(\r\n    mesh: AbstractMesh,\r\n    scene: Scene,\r\n    useLogarithmicDepth: boolean,\r\n    pointsCloud: boolean,\r\n    fogEnabled: boolean,\r\n    alphaTest: boolean,\r\n    defines: any,\r\n    applyDecalAfterDetail: boolean = false\r\n): void {\r\n    if (defines._areMiscDirty) {\r\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n        defines[\"POINTSIZE\"] = pointsCloud;\r\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\r\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n        defines[\"ALPHATEST\"] = alphaTest;\r\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n * @returns true if normals will be required for the rest of the effect\r\n */\r\nexport function PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n    if (!defines._areLightsDirty) {\r\n        return defines._needNormals;\r\n    }\r\n\r\n    let lightIndex = 0;\r\n    const state = {\r\n        needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n        needRebuild: false,\r\n        lightmapMode: false,\r\n        shadowEnabled: false,\r\n        specularEnabled: false,\r\n    };\r\n\r\n    if (scene.lightsEnabled && !disableLighting) {\r\n        for (const light of mesh.lightSources) {\r\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n            lightIndex++;\r\n            if (lightIndex === maxSimultaneousLights) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n    defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n    // Resetting all other lights if any\r\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n        if (defines[\"LIGHT\" + index] !== undefined) {\r\n            defines[\"LIGHT\" + index] = false;\r\n            defines[\"HEMILIGHT\" + index] = false;\r\n            defines[\"POINTLIGHT\" + index] = false;\r\n            defines[\"DIRLIGHT\" + index] = false;\r\n            defines[\"SPOTLIGHT\" + index] = false;\r\n            defines[\"SHADOW\" + index] = false;\r\n            defines[\"SHADOWCSM\" + index] = false;\r\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n            defines[\"SHADOWPCF\" + index] = false;\r\n            defines[\"SHADOWPCSS\" + index] = false;\r\n            defines[\"SHADOWPOISSON\" + index] = false;\r\n            defines[\"SHADOWESM\" + index] = false;\r\n            defines[\"SHADOWCLOSEESM\" + index] = false;\r\n            defines[\"SHADOWCUBE\" + index] = false;\r\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n        }\r\n    }\r\n\r\n    const caps = scene.getEngine().getCaps();\r\n\r\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"SHADOWFLOAT\"] =\r\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n    if (state.needRebuild) {\r\n        defines.rebuild();\r\n    }\r\n\r\n    return state.needNormals;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param light The light the effect is compiling for\r\n * @param lightIndex The index of the light\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param state Defines the current state regarding what is needed (normals, etc...)\r\n * @param state.needNormals\r\n * @param state.needRebuild\r\n * @param state.shadowEnabled\r\n * @param state.specularEnabled\r\n * @param state.lightmapMode\r\n */\r\nexport function PrepareDefinesForLight(\r\n    scene: Scene,\r\n    mesh: AbstractMesh,\r\n    light: Light,\r\n    lightIndex: number,\r\n    defines: any,\r\n    specularSupported: boolean,\r\n    state: {\r\n        needNormals: boolean;\r\n        needRebuild: boolean;\r\n        shadowEnabled: boolean;\r\n        specularEnabled: boolean;\r\n        lightmapMode: boolean;\r\n    }\r\n) {\r\n    state.needNormals = true;\r\n\r\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n    defines[\"HEMILIGHT\" + lightIndex] = false;\r\n    defines[\"POINTLIGHT\" + lightIndex] = false;\r\n    defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n    light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n    // FallOff.\r\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n    switch (light.falloffType) {\r\n        case LightConstants.FALLOFF_GLTF:\r\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_PHYSICAL:\r\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_STANDARD:\r\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n            break;\r\n    }\r\n\r\n    // Specular\r\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n        state.specularEnabled = true;\r\n    }\r\n\r\n    // Shadows\r\n    defines[\"SHADOW\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n    defines[\"SHADOWPCF\" + lightIndex] = false;\r\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n    defines[\"SHADOWESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n        if (shadowGenerator) {\r\n            const shadowMap = shadowGenerator.getShadowMap();\r\n            if (shadowMap) {\r\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                    state.shadowEnabled = true;\r\n                    shadowGenerator.prepareDefines(defines, lightIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n        state.lightmapMode = true;\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n    } else {\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n * @param scene defines the current scene\r\n * @param engine defines the current engine\r\n * @param material defines the material we are compiling the shader for\r\n * @param defines specifies the list of active defines\r\n * @param useInstances defines if instances have to be turned on\r\n * @param useClipPlane defines if clip plane have to be turned on\r\n * @param useThinInstances defines if thin instances have to be turned on\r\n */\r\nexport function PrepareDefinesForFrameBoundValues(\r\n    scene: Scene,\r\n    engine: AbstractEngine,\r\n    material: Material,\r\n    defines: any,\r\n    useInstances: boolean,\r\n    useClipPlane: Nullable<boolean> = null,\r\n    useThinInstances: boolean = false\r\n): void {\r\n    let changed = PrepareDefinesForCamera(scene, defines);\r\n\r\n    if (useClipPlane !== false) {\r\n        changed = prepareDefinesForClipPlanes(material, scene, defines);\r\n    }\r\n\r\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"INSTANCES\"] !== useInstances) {\r\n        defines[\"INSTANCES\"] = useInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for bones\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n            defines[\"BONETEXTURE\"] = true;\r\n        } else {\r\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n            const prePassRenderer = mesh.getScene().prePassRenderer;\r\n            if (prePassRenderer && prePassRenderer.enabled) {\r\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n            }\r\n        }\r\n    } else {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n        defines[\"BonesPerMesh\"] = 0;\r\n        if (defines[\"BONETEXTURE\"] !== undefined) {\r\n            defines[\"BONETEXTURE\"] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for morph targets\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).morphTargetManager;\r\n    if (manager) {\r\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\r\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\r\n\r\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n    } else {\r\n        defines[\"MORPHTARGETS_UV\"] = false;\r\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n        defines[\"MORPHTARGETS\"] = false;\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for baked vertex animation\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n}\r\n\r\n/**\r\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n * @param useBones Precise whether bones should be used or not (override mesh info)\r\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n * @returns false if defines are considered not dirty and have not been checked\r\n */\r\nexport function PrepareDefinesForAttributes(\r\n    mesh: AbstractMesh,\r\n    defines: any,\r\n    useVertexColor: boolean,\r\n    useBones: boolean,\r\n    useMorphTargets = false,\r\n    useVertexAlpha = true,\r\n    useBakedVertexAnimation = true\r\n): boolean {\r\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n        return false;\r\n    }\r\n\r\n    defines._normals = defines._needNormals;\r\n    defines._uvs = defines._needUVs;\r\n\r\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(Constants.NormalKind);\r\n\r\n    if (defines._needNormals && mesh.isVerticesDataPresent(Constants.TangentKind)) {\r\n        defines[\"TANGENT\"] = true;\r\n    }\r\n\r\n    for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n    }\r\n\r\n    if (useVertexColor) {\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(Constants.ColorKind);\r\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n    }\r\n\r\n    if (mesh.isVerticesDataPresent(Constants.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n        defines[\"INSTANCESCOLOR\"] = true;\r\n    }\r\n\r\n    if (useBones) {\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    if (useMorphTargets) {\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    if (useBakedVertexAnimation) {\r\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to multiview\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n    if (scene.activeCamera) {\r\n        const previousMultiview = defines.MULTIVIEW;\r\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n        if (defines.MULTIVIEW != previousMultiview) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to order independant transparency\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param needAlphaBlending Determines if the material needs alpha blending\r\n */\r\nexport function PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the prepass\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n */\r\nexport function PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n    const previousPrePass = defines.PREPASS;\r\n\r\n    if (!defines._arePrePassDirty) {\r\n        return;\r\n    }\r\n\r\n    const texturesList = [\r\n        {\r\n            type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            define: \"PREPASS_ALBEDO_SQRT\",\r\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_DEPTH\",\r\n            index: \"PREPASS_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_NORMAL\",\r\n            index: \"PREPASS_NORMAL_INDEX\",\r\n        },\r\n    ];\r\n\r\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n        defines.PREPASS = true;\r\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n            if (index !== -1) {\r\n                defines[texturesList[i].define] = true;\r\n                defines[texturesList[i].index] = index;\r\n            } else {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n    } else {\r\n        defines.PREPASS = false;\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            defines[texturesList[i].define] = false;\r\n        }\r\n    }\r\n\r\n    if (defines.PREPASS != previousPrePass) {\r\n        defines.markAsUnprocessed();\r\n        defines.markAsImageProcessingDirty();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the defines relative to the active camera\r\n * @param scene defines the current scene\r\n * @param defines specifies the list of active defines\r\n * @returns true if the defines have been updated, else false\r\n */\r\nexport function PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n    let changed = false;\r\n\r\n    if (scene.activeCamera) {\r\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n        const isOrtho = scene.activeCamera.mode === Constants.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n        const isPersp = scene.activeCamera.mode === Constants.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n * @param lightIndex defines the light index\r\n * @param uniformsList The uniform list\r\n * @param samplersList The sampler list\r\n * @param projectedLightTexture defines if projected texture must be used\r\n * @param uniformBuffersList defines an optional list of uniform buffers\r\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n */\r\nexport function PrepareUniformsAndSamplersForLight(\r\n    lightIndex: number,\r\n    uniformsList: string[],\r\n    samplersList: string[],\r\n    projectedLightTexture?: any,\r\n    uniformBuffersList: Nullable<string[]> = null,\r\n    updateOnlyBuffersList = false\r\n) {\r\n    if (uniformBuffersList) {\r\n        uniformBuffersList.push(\"Light\" + lightIndex);\r\n    }\r\n\r\n    if (updateOnlyBuffersList) {\r\n        return;\r\n    }\r\n\r\n    uniformsList.push(\r\n        \"vLightData\" + lightIndex,\r\n        \"vLightDiffuse\" + lightIndex,\r\n        \"vLightSpecular\" + lightIndex,\r\n        \"vLightDirection\" + lightIndex,\r\n        \"vLightFalloff\" + lightIndex,\r\n        \"vLightGround\" + lightIndex,\r\n        \"lightMatrix\" + lightIndex,\r\n        \"shadowsInfo\" + lightIndex,\r\n        \"depthValues\" + lightIndex\r\n    );\r\n\r\n    samplersList.push(\"shadowTexture\" + lightIndex);\r\n    samplersList.push(\"depthTexture\" + lightIndex);\r\n\r\n    uniformsList.push(\r\n        \"viewFrustumZ\" + lightIndex,\r\n        \"cascadeBlendFactor\" + lightIndex,\r\n        \"lightSizeUVCorrection\" + lightIndex,\r\n        \"depthCorrection\" + lightIndex,\r\n        \"penumbraDarkness\" + lightIndex,\r\n        \"frustumLengths\" + lightIndex\r\n    );\r\n\r\n    if (projectedLightTexture) {\r\n        samplersList.push(\"projectionLightTexture\" + lightIndex);\r\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect\r\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n * @param samplersList The sampler list\r\n * @param defines The defines helping in the list generation\r\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n */\r\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n    let uniformsList: string[];\r\n    let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n    if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n        const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n        uniformsList = options.uniformsNames;\r\n        uniformBuffersList = options.uniformBuffersNames;\r\n        samplersList = options.samplers;\r\n        defines = options.defines;\r\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n    } else {\r\n        uniformsList = <string[]>uniformsListOrOptions;\r\n        if (!samplersList) {\r\n            samplersList = [];\r\n        }\r\n    }\r\n\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n        PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\r\n    }\r\n\r\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n        uniformsList.push(\"morphTargetInfluences\");\r\n        uniformsList.push(\"morphTargetCount\");\r\n    }\r\n\r\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n        uniformsList.push(\"bakedVertexAnimationSettings\");\r\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n        uniformsList.push(\"bakedVertexAnimationTime\");\r\n        samplersList.push(\"bakedVertexAnimationTexture\");\r\n    }\r\n}\r\n"]}