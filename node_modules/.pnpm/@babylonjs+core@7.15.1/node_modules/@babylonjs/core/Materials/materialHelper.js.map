{"version":3,"file":"materialHelper.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/materialHelper.ts"],"names":[],"mappings":"AAaA,OAAO,EACH,mBAAmB,EACnB,iBAAiB,EACjB,SAAS,EACT,mBAAmB,EACnB,UAAU,EACV,YAAY,EACZ,yBAAyB,EACzB,sBAAsB,EACtB,iBAAiB,EACjB,WAAW,EACX,yBAAyB,EACzB,wCAAwC,EACxC,yBAAyB,EACzB,6BAA6B,EAC7B,gCAAgC,EAChC,2CAA2C,EAC3C,2BAA2B,EAC3B,qCAAqC,EACrC,sBAAsB,EACtB,uBAAuB,EACvB,iCAAiC,EACjC,sBAAsB,EACtB,uBAAuB,EACvB,yBAAyB,EACzB,qBAAqB,EACrB,6BAA6B,EAC7B,0BAA0B,EAC1B,oBAAoB,EACpB,wBAAwB,EACxB,kCAAkC,EAClC,8BAA8B,EAC9B,0BAA0B,GAC7B,MAAM,4BAA4B,CAAC;AAEpC;;;;;;GAMG;AACH,MAAM,OAAO,cAAc;;AACvB;;;;GAIG;AACW,qCAAsB,GAAsD,sBAAsB,CAAC;AAEjH;;;;;;GAMG;AACW,wCAAyB,GAA8D,yBAAyB,CAAC;AAE/H;;;;;GAKG;AACW,gCAAiB,GAA8E,iBAAiB,CAAC;AAE/H;;;;;GAKG;AACW,0BAAW,GAAkD,WAAW,CAAC;AAEvF;;;;;;;;;;GAUG;AACW,oCAAqB,GASvB,qBAAqB,CAAC;AAElC;;;;;GAKG;AACW,sCAAuB,GAA4C,uBAAuB,CAAC;AAEzG;;;;;;;;;GASG;AACW,gDAAiC,GAQnC,iCAAiC,CAAC;AAE9C;;;;GAIG;AACW,qCAAsB,GAA+C,sBAAsB,CAAC;AAE1G;;;;GAIG;AACW,4CAA6B,GAA+C,6BAA6B,CAAC;AAExH;;;;GAIG;AACW,oDAAqC,GAA+C,qCAAqC,CAAC;AAExI;;;;;;;;;;GAUG;AACW,0CAA2B,GAQ1B,2BAA2B,CAAC;AAE3C;;;;GAIG;AACW,yCAA0B,GAAyC,0BAA0B,CAAC;AAE5G;;;;;GAKG;AACW,mCAAoB,GAAqE,oBAAoB,CAAC;AAE5H;;;;;GAKG;AACW,uCAAwB,GAAkE,wBAAwB,CAAC;AAEjI;;;;;;;;;;;;;;GAcG;AACW,qCAAsB,GAcxB,sBAAsB,CAAC;AAEnC;;;;;;;;;GASG;AACW,sCAAuB,GAOtB,uBAAuB,CAAC;AAEvC;;;;;;;;GAQG;AACW,iDAAkC,GAOpC,kCAAkC,CAAC;AAE/C;;;;;;GAMG;AACW,6CAA8B,GAKhC,8BAA8B,CAAC;AAE3C;;;;;;;GAOG;AACW,wCAAyB,GAAwG,yBAAyB,CAAC;AAEzK;;;;;GAKG;AACW,0DAA2C,GAAyE,2CAA2C,CAAC;AAE9K;;;;;GAKG;AACW,+CAAgC,GAAkE,gCAAgC,CAAC;AAEjJ;;;;;GAKG;AACW,uDAAwC,GAAkE,wCAAwC,CAAC;AAEjK;;;;;;GAMG;AACW,wCAAyB,GAA8F,yBAAyB,CAAC;AAE/J;;;;GAIG;AACW,4CAA6B,GAA0D,6BAA6B,CAAC;AAEnI;;;;GAIG;AACW,yCAA0B,GAAiE,0BAA0B,CAAC;AAEpI;;;;;GAKG;AACW,kCAAmB,GAA+D,mBAAmB,CAAC;AAEpH;;;;;;;;GAQG;AACW,wBAAS,GAA6H,SAAS,CAAC;AAE9J;;;;;;;GAOG;AACW,yBAAU,GAA6G,UAAU,CAAC;AAEhJ;;;;;;GAMG;AACW,gCAAiB,GAAwF,iBAAiB,CAAC;AAEzI;;;;;GAKG;AACW,kCAAmB,GAAgG,mBAAmB,CAAC;AAErJ;;;;GAIG;AACW,wCAAyB,GAAyD,yBAAyB,CAAC;AAE1H;;;;;GAKG;AACW,2BAAY,GAAyD,YAAY,CAAC","sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { PrePassConfiguration } from \"../Materials/prePassConfiguration\";\r\n\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { Material } from \"./material\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLight,\r\n    BindLightProperties,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindSceneUniformBuffer,\r\n    BindTextureMatrix,\r\n    GetFogState,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareAttributesForMorphTargetsInfluencers,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForBakedVertexAnimation,\r\n    PrepareDefinesForBones,\r\n    PrepareDefinesForCamera,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLight,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMorphTargets,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersForLight,\r\n    PrepareUniformsAndSamplersList,\r\n    PushAttributesForInstances,\r\n} from \"./materialHelper.functions\";\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n    /**\r\n     * Binds the scene's uniform buffer to the effect.\r\n     * @param effect defines the effect to bind to the scene uniform buffer\r\n     * @param sceneUbo defines the uniform buffer storing scene data\r\n     */\r\n    public static BindSceneUniformBuffer: (effect: Effect, sceneUbo: UniformBuffer) => void = BindSceneUniformBuffer;\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can across channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV: (texture: BaseTexture, defines: any, key: string) => void = PrepareDefinesForMergedUV;\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corresponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receiving the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix: (texture: BaseTexture, uniformBuffer: UniformBuffer, key: string) => void = BindTextureMatrix;\r\n\r\n    /**\r\n     * Gets the current status of the fog (should it be enabled?)\r\n     * @param mesh defines the mesh to evaluate for fog support\r\n     * @param scene defines the hosting scene\r\n     * @returns true if fog must be enabled\r\n     */\r\n    public static GetFogState: (mesh: AbstractMesh, scene: Scene) => boolean = GetFogState;\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n     */\r\n    public static PrepareDefinesForMisc: (\r\n        mesh: AbstractMesh,\r\n        scene: Scene,\r\n        useLogarithmicDepth: boolean,\r\n        pointsCloud: boolean,\r\n        fogEnabled: boolean,\r\n        alphaTest: boolean,\r\n        defines: any,\r\n        applyDecalAfterDetail?: boolean\r\n    ) => void = PrepareDefinesForMisc;\r\n\r\n    /**\r\n     * Helper used to prepare the defines relative to the active camera\r\n     * @param scene defines the current scene\r\n     * @param defines specifies the list of active defines\r\n     * @returns true if the defines have been updated, else false\r\n     */\r\n    public static PrepareDefinesForCamera: (scene: Scene, defines: any) => boolean = PrepareDefinesForCamera;\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param material defines the material we are compiling the shader for\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     * @param useThinInstances defines if thin instances have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues: (\r\n        scene: Scene,\r\n        engine: AbstractEngine,\r\n        material: Material,\r\n        defines: any,\r\n        useInstances: boolean,\r\n        useClipPlane?: Nullable<boolean>,\r\n        useThinInstances?: boolean\r\n    ) => void = PrepareDefinesForFrameBoundValues;\r\n\r\n    /**\r\n     * Prepares the defines for bones\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBones: (mesh: AbstractMesh, defines: any) => void = PrepareDefinesForBones;\r\n\r\n    /**\r\n     * Prepares the defines for morph targets\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMorphTargets: (mesh: AbstractMesh, defines: any) => void = PrepareDefinesForMorphTargets;\r\n\r\n    /**\r\n     * Prepares the defines for baked vertex animation\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForBakedVertexAnimation: (mesh: AbstractMesh, defines: any) => void = PrepareDefinesForBakedVertexAnimation;\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes: (\r\n        mesh: AbstractMesh,\r\n        defines: any,\r\n        useVertexColor: boolean,\r\n        useBones: boolean,\r\n        useMorphTargets?: boolean,\r\n        useVertexAlpha?: boolean,\r\n        useBakedVertexAnimation?: boolean\r\n    ) => boolean = PrepareDefinesForAttributes;\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview: (scene: Scene, defines: any) => void = PrepareDefinesForMultiview;\r\n\r\n    /**\r\n     * Prepares the defines related to order independant transparency\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param needAlphaBlending Determines if the material needs alpha blending\r\n     */\r\n    public static PrepareDefinesForOIT: (scene: Scene, defines: any, needAlphaBlending: boolean) => void = PrepareDefinesForOIT;\r\n\r\n    /**\r\n     * Prepares the defines related to the prepass\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n     */\r\n    public static PrepareDefinesForPrePass: (scene: Scene, defines: any, canRenderToMRT: boolean) => void = PrepareDefinesForPrePass;\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param light The light the effect is compiling for\r\n     * @param lightIndex The index of the light\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param state Defines the current state regarding what is needed (normals, etc...)\r\n     * @param state.needNormals\r\n     * @param state.needRebuild\r\n     * @param state.shadowEnabled\r\n     * @param state.specularEnabled\r\n     * @param state.lightmapMode\r\n     */\r\n    public static PrepareDefinesForLight: (\r\n        scene: Scene,\r\n        mesh: AbstractMesh,\r\n        light: Light,\r\n        lightIndex: number,\r\n        defines: any,\r\n        specularSupported: boolean,\r\n        state: {\r\n            needNormals: boolean;\r\n            needRebuild: boolean;\r\n            shadowEnabled: boolean;\r\n            specularEnabled: boolean;\r\n            lightmapMode: boolean;\r\n        }\r\n    ) => void = PrepareDefinesForLight;\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights: (\r\n        scene: Scene,\r\n        mesh: AbstractMesh,\r\n        defines: any,\r\n        specularSupported: boolean,\r\n        maxSimultaneousLights?: number,\r\n        disableLighting?: boolean\r\n    ) => boolean = PrepareDefinesForLights;\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n     * @param lightIndex defines the light index\r\n     * @param uniformsList The uniform list\r\n     * @param samplersList The sampler list\r\n     * @param projectedLightTexture defines if projected texture must be used\r\n     * @param uniformBuffersList defines an optional list of uniform buffers\r\n     * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n     */\r\n    public static PrepareUniformsAndSamplersForLight: (\r\n        lightIndex: number,\r\n        uniformsList: string[],\r\n        samplersList: string[],\r\n        projectedLightTexture?: any,\r\n        uniformBuffersList?: Nullable<string[]>,\r\n        updateOnlyBuffersList?: boolean\r\n    ) => void = PrepareUniformsAndSamplersForLight;\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n     * @param samplersList The sampler list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList: (\r\n        uniformsListOrOptions: string[] | IEffectCreationOptions,\r\n        samplersList?: string[],\r\n        defines?: any,\r\n        maxSimultaneousLights?: number\r\n    ) => void = PrepareUniformsAndSamplersList;\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows: (defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights?: number, rank?: number) => number = HandleFallbacksForShadows;\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param influencers The number of influencers\r\n     */\r\n    public static PrepareAttributesForMorphTargetsInfluencers: (attribs: string[], mesh: AbstractMesh, influencers: number) => void = PrepareAttributesForMorphTargetsInfluencers;\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets: (attribs: string[], mesh: AbstractMesh, defines: any) => void = PrepareAttributesForMorphTargets;\r\n\r\n    /**\r\n     * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare for baked vertex animations\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForBakedVertexAnimation: (attribs: string[], mesh: AbstractMesh, defines: any) => void = PrepareAttributesForBakedVertexAnimation;\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current effect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones: (attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks) => void = PrepareAttributesForBones;\r\n\r\n    /**\r\n     * Check and prepare the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current MaterialDefines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances: (attribs: string[], defines: MaterialDefines) => void = PrepareAttributesForInstances;\r\n\r\n    /**\r\n     * Add the list of attributes required for instances to the attribs array.\r\n     * @param attribs The current list of supported attribs\r\n     * @param needsPreviousMatrices If the shader needs previous matrices\r\n     */\r\n    public static PushAttributesForInstances: (attribs: string[], needsPreviousMatrices?: boolean) => void = PushAttributesForInstances;\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties: (light: Light, effect: Effect, lightIndex: number) => void = BindLightProperties;\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param light Light to bind\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public static BindLight: (light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows?: boolean) => void = BindLight;\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     */\r\n    public static BindLights: (scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights?: number) => void = BindLights;\r\n\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters: (scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace?: boolean) => void = BindFogParameters;\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n     */\r\n    public static BindBonesParameters: (mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration) => void = BindBonesParameters;\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters: (abstractMesh: AbstractMesh, effect: Effect) => void = BindMorphTargetParameters;\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth: (defines: any, effect: Effect, scene: Scene) => void = BindLogDepth;\r\n}\r\n"]}