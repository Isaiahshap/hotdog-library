{"version":3,"file":"dracoCompression.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompression.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { DecoderModule } from \"draco3dgltf\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { decodeMesh, type AttributeData, type Message, workerFunction, initializeWebWorker } from \"./dracoCompressionWorker\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\ninterface MeshData {\r\n    indices?: Uint16Array | Uint32Array;\r\n    attributes: Array<AttributeData>;\r\n    totalVertices: number;\r\n}\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer, jsModule?: DracoDecoderModule): Promise<{ module: DecoderModule }> {\r\n    return new Promise((resolve) => {\r\n        (jsModule || DracoDecoderModule)({ wasmBinary }).then((module) => {\r\n            resolve({ module });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n        /**\r\n         * Optional worker pool to use for async decoding instead of creating a new worker pool.\r\n         */\r\n        workerPool?: AutoReleaseWorkerPool;\r\n        /**\r\n         * Optional ArrayBuffer of the WebAssembly binary\r\n         */\r\n        wasmBinary?: ArrayBuffer;\r\n\r\n        /**\r\n         * The decoder module if already available.\r\n         */\r\n        jsModule?: any /* DecoderModule */;\r\n    };\r\n}\r\n\r\n/**\r\n * Options for Draco compression\r\n */\r\nexport interface IDracoCompressionOptions {\r\n    /**\r\n     * The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n    /**\r\n     * Optional ArrayBuffer of the WebAssembly binary.\r\n     * If provided it will be used instead of loading the binary from wasmBinaryUrl.\r\n     */\r\n    wasmBinary?: ArrayBuffer;\r\n    /**\r\n     * Optional worker pool to use for async decoding.\r\n     * If provided, numWorkers will be ignored and the worker pool will be used instead.\r\n     * If provided the draco script will not be loaded from the DracoConfiguration.\r\n     */\r\n    workerPool?: AutoReleaseWorkerPool;\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<{ module: DecoderModule }>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n            wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n            fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default draco compression object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static Configuration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoCompression._Default) {\r\n            if (!skipDispose) {\r\n                DracoCompression._Default.dispose();\r\n            }\r\n            DracoCompression._Default = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations Or an options object. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers: number | IDracoCompressionOptions = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        // check if the decoder binary and worker pool was injected\r\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\r\n        if (decoder.workerPool || (typeof numWorkers === \"object\" && numWorkers.workerPool)) {\r\n            // set the promise accordingly\r\n            this._workerPoolPromise = Promise.resolve(decoder.workerPool || (numWorkers as IDracoCompressionOptions).workerPool!);\r\n        } else {\r\n            // to avoid making big changes to the decider, if wasmBinary is provided use it in the wasmBinaryPromise\r\n            const wasmBinaryProvided = decoder.wasmBinary || (typeof numWorkers === \"object\" && numWorkers.wasmBinary);\r\n            const numberOfWorkers = typeof numWorkers === \"number\" ? numWorkers : numWorkers.numWorkers;\r\n            const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\r\n            const urlNeeded = useWorkers || (!useWorkers && !decoder.jsModule);\r\n            // code maintained here for back-compat with no changes\r\n\r\n            const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | undefined> } =\r\n                decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                    ? {\r\n                          url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.wasmUrl, true) : \"\",\r\n                          wasmBinaryPromise: wasmBinaryProvided ? Promise.resolve(wasmBinaryProvided) : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true)),\r\n                      }\r\n                    : {\r\n                          url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.fallbackUrl!) : \"\",\r\n                          wasmBinaryPromise: Promise.resolve(undefined),\r\n                      };\r\n            if (useWorkers) {\r\n                this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                    const workerContent = `${decodeMesh}(${workerFunction})()`;\r\n                    const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                    return new AutoReleaseWorkerPool(numberOfWorkers as number, () => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        return initializeWebWorker(worker, decoderWasmBinary, decoderInfo.url);\r\n                    });\r\n                });\r\n            } else {\r\n                this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(async (decoderWasmBinary) => {\r\n                    if (typeof DracoDecoderModule === \"undefined\") {\r\n                        if (!decoder.jsModule) {\r\n                            if (!decoderInfo.url) {\r\n                                throw new Error(\"Draco decoder module is not available\");\r\n                            }\r\n                            await Tools.LoadBabylonScriptAsync(decoderInfo.url);\r\n                        }\r\n                    }\r\n                    return await createDecoderAsync(decoderWasmBinary as ArrayBuffer, decoder.jsModule);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public async whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            await this._workerPoolPromise;\r\n            return;\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            await this._decoderModulePromise;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to mesh data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\r\n     * @returns A promise that resolves with the decoded mesh data\r\n     */\r\n    public decodeMeshToMeshDataAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<AttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<Message>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<AttributeData> = [];\r\n\r\n                const numPoints = decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public async decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\r\n        const geometry = new Geometry(name, scene);\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n\r\n    /** @internal */\r\n    public async _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean }\r\n    ): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\r\n        const geometry = new Geometry(name, scene);\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\r\n     */\r\n    public async decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\r\n        const vertexData = new VertexData();\r\n        if (meshData.indices) {\r\n            vertexData.indices = meshData.indices;\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            const floatData = VertexBuffer.GetFloatData(\r\n                attribute.data,\r\n                attribute.size,\r\n                VertexBuffer.GetDataType(attribute.data),\r\n                attribute.byteOffset,\r\n                attribute.byteStride,\r\n                attribute.normalized,\r\n                meshData.totalVertices\r\n            );\r\n\r\n            vertexData.set(floatData, attribute.kind);\r\n        }\r\n        return vertexData;\r\n    }\r\n}\r\n"]}