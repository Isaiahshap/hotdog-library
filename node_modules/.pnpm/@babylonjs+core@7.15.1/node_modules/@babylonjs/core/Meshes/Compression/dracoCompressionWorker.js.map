{"version":3,"file":"dracoCompressionWorker.js","sourceRoot":"","sources":["../../../../../dev/core/src/Meshes/Compression/dracoCompressionWorker.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { DecoderBuffer, Decoder, Mesh, PointCloud, Status } from \"draco3dgltf\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\nexport interface AttributeData {\r\n    kind: string;\r\n    data: ArrayBufferView;\r\n    size: number;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    normalized: boolean;\r\n}\r\n\r\ninterface InitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\ninterface DecodeMeshDoneMessage {\r\n    id: \"decodeMeshDone\";\r\n    totalVertices: number;\r\n}\r\n\r\ninterface IndicesMessage {\r\n    id: \"indices\";\r\n    data: Uint16Array | Uint32Array;\r\n}\r\n\r\ninterface AttributeMessage extends AttributeData {\r\n    id: \"attribute\";\r\n}\r\nexport type Message = InitDoneMessage | DecodeMeshDoneMessage | IndicesMessage | AttributeMessage;\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: Message, transfer?: any[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function decodeMesh(\r\n    decoderModule: any /*DecoderModule*/,\r\n    data: Int8Array,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder() as Decoder;\r\n\r\n        buffer = new decoderModule.DecoderBuffer() as DecoderBuffer;\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh as Mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud as PointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: { [kind: string]: number } = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function workerFunction(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                const decoder = message.decoder;\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                }\r\n                const initDecoderObject = decoder.wasmBinary ? { wasmBinary: decoder.wasmBinary } : {};\r\n                decoderPromise = DracoDecoderModule(initDecoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = decodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Initializes a worker that was created for the draco agent pool\r\n * @param worker  The worker to initialize\r\n * @param decoderWasmBinary The wasm binary to load into the worker\r\n * @param moduleUrl The url to the draco decoder module (optional)\r\n * @returns A promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, decoderWasmBinary?: ArrayBuffer, moduleUrl?: string): Promise<Worker> {\r\n    return new Promise<Worker>((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (event: MessageEvent<Message>) => {\r\n            if (event.data.id === \"initDone\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        if (!decoderWasmBinary) {\r\n            worker.postMessage({\r\n                id: \"init\",\r\n                decoder: {\r\n                    url: moduleUrl,\r\n                },\r\n            });\r\n        } else {\r\n            // clone the array buffer to make it transferable\r\n            const clone = decoderWasmBinary.slice(0);\r\n            worker.postMessage(\r\n                {\r\n                    id: \"init\",\r\n                    decoder: {\r\n                        url: moduleUrl,\r\n                        wasmBinary: clone,\r\n                    },\r\n                },\r\n                [clone]\r\n            );\r\n        }\r\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\r\n    });\r\n}\r\n"]}