{"version":3,"file":"webgpuTextureManager.js","sourceRoot":"","sources":["../../../../../dev/core/src/Engines/WebGPU/webgpuTextureManager.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\n// License for the mipmap generation code:\r\n//\r\n// Copyright 2020 Brandon Jones\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUTintWASM } from \"./webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\n// TODO WEBGPU improve mipmap generation by using compute shaders\r\n\r\n// TODO WEBGPU use WGSL instead of GLSL\r\nconst mipmapVertexSource = `\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\r\n\r\n    layout(location = 0) out vec2 vTex;\r\n\r\n    void main() {\r\n        vTex = tex[gl_VertexIndex];\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst mipmapFragmentSource = `\r\n    layout(set = 0, binding = 0) uniform sampler imgSampler;\r\n    layout(set = 0, binding = 1) uniform texture2D img;\r\n\r\n    layout(location = 0) in vec2 vTex;\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        outColor = texture(sampler2D(img, imgSampler), vTex);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaVertexSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) out flat ivec2 vTextureSize;\r\n    #endif\r\n\r\n    void main() {\r\n        #ifdef INVERTY\r\n            vTextureSize = textureSize(img, 0);\r\n        #endif\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaFragmentSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) in flat ivec2 vTextureSize;\r\n    #endif\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n    #ifdef INVERTY\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, vTextureSize.y - gl_FragCoord.y), 0);\r\n    #else\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color.rgb *= color.a;\r\n    #endif\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n    layout(set = 0, binding = 1) uniform Params {\r\n        float ofstX;\r\n        float ofstY;\r\n        float width;\r\n        float height;\r\n    };\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) in flat ivec2 vTextureSize;\r\n    #endif\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        if (gl_FragCoord.x < ofstX || gl_FragCoord.x >= ofstX + width) {\r\n            discard;\r\n        }\r\n        if (gl_FragCoord.y < ofstY || gl_FragCoord.y >= ofstY + height) {\r\n            discard;\r\n        }\r\n    #ifdef INVERTY\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, ofstY + height - (gl_FragCoord.y - ofstY)), 0);\r\n    #else\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color.rgb *= color.a;\r\n    #endif\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst clearVertexSource = `\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n\r\n    void main() {\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst clearFragmentSource = `\r\n    layout(set = 0, binding = 0) uniform Uniforms {\r\n        uniform vec4 color;\r\n    };\r\n\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureVertexSource = `\r\n    struct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n        @location(0) fragUV : vec2<f32>\r\n    }\r\n\r\n    @vertex\r\n    fn main(\r\n        @builtin(vertex_index) VertexIndex : u32\r\n    ) -> VertexOutput {\r\n        var pos = array<vec2<f32>, 4>(\r\n            vec2(-1.0,  1.0),\r\n            vec2( 1.0,  1.0),\r\n            vec2(-1.0, -1.0),\r\n            vec2( 1.0, -1.0)\r\n        );\r\n        var tex = array<vec2<f32>, 4>(\r\n            vec2(0.0, 0.0),\r\n            vec2(1.0, 0.0),\r\n            vec2(0.0, 1.0),\r\n            vec2(1.0, 1.0)\r\n        );\r\n\r\n        var output: VertexOutput;\r\n\r\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        output.fragUV = tex[VertexIndex];\r\n\r\n        return output;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureInvertYFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\r\n    }\r\n    `;\r\n\r\nenum PipelineType {\r\n    MipMap = 0,\r\n    InvertYPremultiplyAlpha = 1,\r\n    Clear = 2,\r\n    InvertYPremultiplyAlphaWithOfst = 3,\r\n}\r\n\r\nenum VideoPipelineType {\r\n    DontInvertY = 0,\r\n    InvertY = 1,\r\n}\r\n\r\ninterface IPipelineParameters {\r\n    invertY?: boolean;\r\n    premultiplyAlpha?: boolean;\r\n}\r\n\r\nconst shadersForPipelineType = [\r\n    { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },\r\n    { vertex: clearVertexSource, fragment: clearFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource },\r\n];\r\n\r\n/**\r\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\r\n * The number of entries should not go over 64! Else, the code in WebGPUCacheRenderPipeline.setMRT should be updated\r\n */\r\nexport const renderableTextureFormatToIndex: { [name: string]: number } = {\r\n    \"\": 0,\r\n    r8unorm: 1,\r\n    r8uint: 2,\r\n    r8sint: 3,\r\n\r\n    r16uint: 4,\r\n    r16sint: 5,\r\n    r16float: 6,\r\n    rg8unorm: 7,\r\n    rg8uint: 8,\r\n    rg8sint: 9,\r\n\r\n    r32uint: 10,\r\n    r32sint: 11,\r\n    r32float: 12,\r\n    rg16uint: 13,\r\n    rg16sint: 14,\r\n    rg16float: 15,\r\n    rgba8unorm: 16,\r\n    \"rgba8unorm-srgb\": 17,\r\n    rgba8uint: 18,\r\n    rgba8sint: 19,\r\n    bgra8unorm: 20,\r\n    \"bgra8unorm-srgb\": 21,\r\n\r\n    rgb10a2uint: 22,\r\n    rgb10a2unorm: 23,\r\n    /* rg11b10ufloat: this entry is dynamically added if the \"RG11B10UFloatRenderable\" extension is supported */\r\n\r\n    rg32uint: 24,\r\n    rg32sint: 25,\r\n    rg32float: 26,\r\n    rgba16uint: 27,\r\n    rgba16sint: 28,\r\n    rgba16float: 29,\r\n\r\n    rgba32uint: 30,\r\n    rgba32sint: 31,\r\n    rgba32float: 32,\r\n\r\n    stencil8: 33,\r\n    depth16unorm: 34,\r\n    depth24plus: 35,\r\n    \"depth24plus-stencil8\": 36,\r\n    depth32float: 37,\r\n\r\n    \"depth32float-stencil8\": 38,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUTextureManager {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _glslang: any;\r\n    private _tintWASM: Nullable<WebGPUTintWASM>;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _mipmapSampler: GPUSampler;\r\n    private _videoSampler: GPUSampler;\r\n    private _ubCopyWithOfst: GPUBuffer;\r\n    private _pipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _compiledShaders: GPUShaderModule[][] = [];\r\n    private _videoPipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _videoCompiledShaders: GPUShaderModule[][] = [];\r\n    private _deferredReleaseTextures: Array<[Nullable<HardwareTextureWrapper | GPUTexture>, Nullable<BaseTexture>]> = [];\r\n    private _commandEncoderForCreation: GPUCommandEncoder;\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                         Initialization / Helpers\r\n    //------------------------------------------------------------------------------\r\n\r\n    constructor(\r\n        engine: WebGPUEngine,\r\n        device: GPUDevice,\r\n        glslang: any,\r\n        tintWASM: Nullable<WebGPUTintWASM>,\r\n        bufferManager: WebGPUBufferManager,\r\n        enabledExtensions: GPUFeatureName[]\r\n    ) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._glslang = glslang;\r\n        this._tintWASM = tintWASM;\r\n        this._bufferManager = bufferManager;\r\n\r\n        if (enabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) !== -1) {\r\n            const keys = Object.keys(renderableTextureFormatToIndex);\r\n            renderableTextureFormatToIndex[WebGPUConstants.TextureFormat.RG11B10UFloat] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;\r\n        }\r\n\r\n        this._mipmapSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._videoSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._ubCopyWithOfst = this._bufferManager.createBuffer(\r\n            4 * 4,\r\n            WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst,\r\n            \"UBCopyWithOffset\"\r\n        ).underlyingResource;\r\n\r\n        this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n        this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n    }\r\n\r\n    private _getPipeline(format: GPUTextureFormat, type: PipelineType = PipelineType.MipMap, params?: IPipelineParameters): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index =\r\n            type === PipelineType.MipMap\r\n                ? 1 << 0\r\n                : type === PipelineType.InvertYPremultiplyAlpha\r\n                  ? ((params!.invertY ? 1 : 0) << 1) + ((params!.premultiplyAlpha ? 1 : 0) << 2)\r\n                  : type === PipelineType.Clear\r\n                    ? 1 << 3\r\n                    : type === PipelineType.InvertYPremultiplyAlphaWithOfst\r\n                      ? ((params!.invertY ? 1 : 0) << 4) + ((params!.premultiplyAlpha ? 1 : 0) << 5)\r\n                      : 0;\r\n\r\n        if (!this._pipelines[format]) {\r\n            this._pipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._pipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let defines = \"#version 450\\n\";\r\n            if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\r\n                if (params!.invertY) {\r\n                    defines += \"#define INVERTY\\n\";\r\n                }\r\n                if (params!.premultiplyAlpha) {\r\n                    defines += \"#define PREMULTIPLYALPHA\\n\";\r\n                }\r\n            }\r\n\r\n            let modules = this._compiledShaders[index];\r\n            if (!modules) {\r\n                let vertexCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].vertex, \"vertex\");\r\n                let fragmentCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].fragment, \"fragment\");\r\n\r\n                if (this._tintWASM) {\r\n                    vertexCode = this._tintWASM.convertSpirV2WGSL(vertexCode);\r\n                    fragmentCode = this._tintWASM.convertSpirV2WGSL(fragmentCode);\r\n                }\r\n\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: vertexCode,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: fragmentCode,\r\n                });\r\n                modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private _getVideoPipeline(format: GPUTextureFormat, type: VideoPipelineType = VideoPipelineType.DontInvertY): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\r\n\r\n        if (!this._videoPipelines[format]) {\r\n            this._videoPipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._videoPipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let modules = this._videoCompiledShaders[index];\r\n            if (!modules) {\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: copyVideoToTextureVertexSource,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,\r\n                });\r\n                modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    public setCommandEncoder(encoder: GPUCommandEncoder): void {\r\n        this._commandEncoderForCreation = encoder;\r\n    }\r\n\r\n    public copyVideoToTexture(video: ExternalTexture, texture: InternalTexture, format: GPUTextureFormat, invertY = false, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\r\n\r\n        const webgpuHardwareTexture = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}${texture.label ? \"_\" + texture.label : \"\"}`,\r\n            colorAttachments: [\r\n                {\r\n                    view: webgpuHardwareTexture.underlyingResource!.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.All,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: this._videoSampler,\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: this._device.importExternalTexture({\r\n                        source: video.underlyingResource,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public invertYPreMultiplyAlpha(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        faceIndex = 0,\r\n        mipLevel = 0,\r\n        layers = 1,\r\n        ofstX = 0,\r\n        ofstY = 0,\r\n        rectWidth = 0,\r\n        rectHeight = 0,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const useRect = rectWidth !== 0;\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\r\n            invertY,\r\n            premultiplyAlpha,\r\n        });\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\r\n                // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\r\n                gpuOrHdwTexture = undefined as any;\r\n            }\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        if (useRect) {\r\n            this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        const outputTexture =\r\n            webgpuHardwareTexture?._copyInvertYTempTexture ??\r\n            this.createTexture(\r\n                { width, height, layers: 1 },\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                format,\r\n                1,\r\n                commandEncoder,\r\n                WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding,\r\n                undefined,\r\n                \"TempTextureForCopyWithInvertY\"\r\n            );\r\n\r\n        const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}_${\r\n                premultiplyAlpha ? \"PremultiplyAlpha\" : \"DontPremultiplyAlpha\"\r\n            }`,\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        baseMipLevel: 0,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                        baseArrayLayer: 0,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\r\n        if (!bindGroup) {\r\n            const descriptor: GPUBindGroupDescriptor = {\r\n                layout: bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: mipLevel,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: layers,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                    },\r\n                ],\r\n            };\r\n            if (useRect) {\r\n                descriptor.entries.push({\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this._ubCopyWithOfst,\r\n                    },\r\n                });\r\n            }\r\n            bindGroup = this._device.createBindGroup(descriptor);\r\n        }\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.copyTextureToTexture(\r\n            {\r\n                texture: outputTexture,\r\n            },\r\n            {\r\n                texture: gpuTexture,\r\n                mipLevel,\r\n                origin: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    z: faceIndex,\r\n                },\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        if (webgpuHardwareTexture) {\r\n            webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\r\n            webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\r\n            if (useRect) {\r\n                webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\r\n            } else {\r\n                webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\r\n            }\r\n        } else {\r\n            this._deferredReleaseTextures.push([outputTexture, null]);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public copyWithInvertY(srcTextureView: GPUTextureView, format: GPUTextureFormat, renderPassDescriptor: GPURenderPassDescriptor, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, { invertY: true, premultiplyAlpha: false });\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal copy texture with invertY`);\r\n\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const bindGroup = this._device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: srcTextureView,\r\n                },\r\n            ],\r\n        });\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                               Creation\r\n    //------------------------------------------------------------------------------\r\n\r\n    public createTexture(\r\n        imageBitmap: ImageBitmap | { width: number; height: number; layers: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        is3D = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const layerCount = (imageBitmap as any).layers || 1;\r\n        const textureSize = {\r\n            width: imageBitmap.width,\r\n            height: imageBitmap.height,\r\n            depthOrArrayLayers: layerCount,\r\n        };\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat && !is3D) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? \"3D\" : \"2D\"}_${label ? label + \"_\" : \"\"}${textureSize.width}x${textureSize.height}x${\r\n                textureSize.depthOrArrayLayers\r\n            }_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: textureSize,\r\n            dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n            this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, is3D, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public createCubeTexture(\r\n        imageBitmaps: ImageBitmap[] | { width: number; height: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0,\r\n        label?: string\r\n    ): GPUTexture {\r\n        sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\r\n\r\n        const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\r\n        const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\r\n\r\n        const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\r\n\r\n        if (!isCompressedFormat) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + \"_\" : \"\"}${width}x${height}x6_${\r\n                hasMipmaps ? \"wmips\" : \"womips\"\r\n            }_${format}_samples${sampleCount}`,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 6,\r\n            },\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\r\n            this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public generateCubeMipmaps(gpuTexture: GPUTexture | WebGPUHardwareTexture, format: GPUTextureFormat, mipLevelCount: number, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\r\n\r\n        for (let f = 0; f < 6; ++f) {\r\n            this.generateMipmaps(gpuTexture, format, mipLevelCount, f, false, commandEncoder);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public generateMipmaps(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        format: GPUTextureFormat,\r\n        mipLevelCount: number,\r\n        faceIndex = 0,\r\n        is3D = false,\r\n        commandEncoder?: GPUCommandEncoder\r\n    ): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format);\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\r\n            gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n        for (let i = 1; i < mipLevelCount; ++i) {\r\n            const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\r\n                label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,\r\n                colorAttachments: [\r\n                    {\r\n                        view: gpuTexture.createView({\r\n                            format,\r\n                            dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: i,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: 1,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                        loadOp: WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    },\r\n                ],\r\n            };\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\r\n            }\r\n            const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n            const bindGroup =\r\n                webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ??\r\n                this._device.createBindGroup({\r\n                    layout: bindGroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: this._mipmapSampler,\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: gpuTexture.createView({\r\n                                format,\r\n                                dimension: is3D ? WebGPUConstants.TextureViewDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\r\n                                baseMipLevel: i - 1,\r\n                                mipLevelCount: 1,\r\n                                arrayLayerCount: 1,\r\n                                baseArrayLayer: faceIndex,\r\n                            }),\r\n                        },\r\n                    ],\r\n                });\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\r\n            }\r\n\r\n            passEncoder.setPipeline(pipeline);\r\n            passEncoder.setBindGroup(0, bindGroup);\r\n            passEncoder.draw(4, 1, 0, 0);\r\n            passEncoder.end();\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public createGPUTextureForInternalTexture(texture: InternalTexture, width?: number, height?: number, depth?: number, creationFlags?: number): WebGPUHardwareTexture {\r\n        if (!texture._hardwareTexture) {\r\n            texture._hardwareTexture = new WebGPUHardwareTexture();\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = texture.width;\r\n        }\r\n        if (height === undefined) {\r\n            height = texture.height;\r\n        }\r\n        if (depth === undefined) {\r\n            depth = texture.depth;\r\n        }\r\n\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const isStorageTexture = ((creationFlags ?? 0) & Constants.TEXTURE_CREATIONFLAG_STORAGE) !== 0;\r\n\r\n        gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\r\n\r\n        gpuTextureWrapper.textureUsages =\r\n            texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : texture._source === InternalTextureSource.DepthStencil\r\n                  ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment\r\n                  : -1;\r\n\r\n        gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\r\n\r\n        const hasMipMaps = texture.generateMipMaps;\r\n        const layerCount = depth || 1;\r\n        let mipmapCount;\r\n        if (texture._maxLodLevel !== null) {\r\n            mipmapCount = texture._maxLodLevel;\r\n        } else {\r\n            mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width!, height!) : 1;\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            const gpuTexture = this.createCubeTexture(\r\n                { width, height },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${\r\n                        hasMipMaps ? \"wmips\" : \"womips\"\r\n                    }_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: 6,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        } else {\r\n            const gpuTexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages,\r\n                texture.label\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n\r\n            const arrayLayerCount = texture.is3D ? 1 : layerCount;\r\n            const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\r\n            const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\r\n            const dimension = texture.is2DArray\r\n                ? WebGPUConstants.TextureViewDimension.E2dArray\r\n                : texture.is3D\r\n                  ? WebGPUConstants.TextureDimension.E3d\r\n                  : WebGPUConstants.TextureViewDimension.E2d;\r\n\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? \"3D\" : \"2D\"}${\r\n                        texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"\r\n                    }_${width}x${height}${texture.is3D ? \"x\" + layerCount : \"\"}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}_${texture.label ?? \"noname\"}`,\r\n                    format,\r\n                    dimension,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount,\r\n                    aspect,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        }\r\n\r\n        texture.width = texture.baseWidth = width;\r\n        texture.height = texture.baseHeight = height;\r\n        texture.depth = texture.baseDepth = depth;\r\n\r\n        this.createMSAATexture(texture, texture.samples);\r\n\r\n        return gpuTextureWrapper;\r\n    }\r\n\r\n    public createMSAATexture(texture: InternalTexture, samples: number, releaseExisting = true, index = -1): void {\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (releaseExisting) {\r\n            gpuTextureWrapper?.releaseMSAATexture();\r\n        }\r\n\r\n        if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n\r\n        const gpuMSAATexture = this.createTexture(\r\n            { width, height, layers: 1 },\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            false,\r\n            gpuTextureWrapper.format,\r\n            samples,\r\n            this._commandEncoderForCreation,\r\n            WebGPUConstants.TextureUsage.RenderAttachment,\r\n            0,\r\n            texture.label ? \"MSAA\" + texture.label : undefined\r\n        );\r\n        gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                                  Update\r\n    //------------------------------------------------------------------------------\r\n\r\n    public updateCubeTextures(\r\n        imageBitmaps: ImageBitmap[] | Uint8Array[],\r\n        gpuTexture: GPUTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0\r\n    ): void {\r\n        const faces = [0, 3, 1, 4, 2, 5];\r\n\r\n        for (let f = 0; f < faces.length; ++f) {\r\n            const imageBitmap = imageBitmaps[faces[f]];\r\n\r\n            this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\r\n        }\r\n    }\r\n\r\n    // TODO WEBGPU handle data source not being in the same format than the destination texture?\r\n    public updateTexture(\r\n        imageBitmap: ImageBitmap | Uint8Array | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas,\r\n        texture: GPUTexture | InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        layers: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture).underlyingResource! : texture;\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n        const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture) : texture;\r\n\r\n        const textureCopyView: GPUImageCopyTextureTagged = {\r\n            texture: gpuTexture,\r\n            origin: {\r\n                x: offsetX,\r\n                y: offsetY,\r\n                z: Math.max(faceIndex, 0),\r\n            },\r\n            mipLevel: mipLevel,\r\n            premultipliedAlpha: premultiplyAlpha,\r\n        };\r\n\r\n        const textureExtent = {\r\n            width: Math.ceil(width / blockInformation.width) * blockInformation.width,\r\n            height: Math.ceil(height / blockInformation.height) * blockInformation.height,\r\n            depthOrArrayLayers: layers || 1,\r\n        };\r\n\r\n        if ((imageBitmap as Uint8Array).byteLength !== undefined) {\r\n            imageBitmap = imageBitmap as Uint8Array;\r\n\r\n            const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n            const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\r\n\r\n            if (aligned) {\r\n                const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                const buffer = this._bufferManager.createRawBuffer(\r\n                    imageBitmap.byteLength,\r\n                    WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc,\r\n                    true,\r\n                    \"TempBufferForUpdateTexture\" + (gpuTexture ? \"_\" + gpuTexture.label : \"\")\r\n                );\r\n\r\n                const arrayBuffer = buffer.getMappedRange();\r\n\r\n                new Uint8Array(arrayBuffer).set(imageBitmap);\r\n\r\n                buffer.unmap();\r\n\r\n                commandEncoder!.copyBufferToTexture(\r\n                    {\r\n                        buffer: buffer,\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureCopyView,\r\n                    textureExtent\r\n                );\r\n\r\n                this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n                this._bufferManager.releaseBuffer(buffer);\r\n            } else {\r\n                this._device.queue.writeTexture(\r\n                    textureCopyView,\r\n                    imageBitmap,\r\n                    {\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureExtent\r\n                );\r\n            }\r\n\r\n            if (invertY || premultiplyAlpha) {\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n                    const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        texture.width,\r\n                        texture.height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        offsetX,\r\n                        offsetY,\r\n                        dontUseRect ? 0 : width,\r\n                        dontUseRect ? 0 : height,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we should never take this code path\r\n                    // eslint-disable-next-line no-throw-literal\r\n                    throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\r\n                }\r\n            }\r\n        } else {\r\n            imageBitmap = imageBitmap as ImageBitmap | ImageData | HTMLImageElement | HTMLVideoElement | VideoFrame | HTMLCanvasElement | OffscreenCanvas;\r\n\r\n            if (invertY) {\r\n                textureCopyView.premultipliedAlpha = false; // we are going to handle premultiplyAlpha ourselves\r\n\r\n                // we must preprocess the image\r\n                if (WebGPUTextureHelper.IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {\r\n                    // optimization when the source image is the same size than the destination texture and offsets X/Y == 0:\r\n                    // we simply copy the source to the destination and we apply the preprocessing on the destination\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we must apply the preprocessing on the source image before copying it into the destination texture\r\n                    const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                    // create a temp texture and copy the image to it\r\n                    const srcTexture = this.createTexture(\r\n                        { width, height, layers: 1 },\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        format,\r\n                        1,\r\n                        commandEncoder,\r\n                        WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.TextureBinding,\r\n                        undefined,\r\n                        \"TempTextureForUpdateTexture\"\r\n                    );\r\n\r\n                    this._deferredReleaseTextures.push([srcTexture, null]);\r\n\r\n                    textureExtent.depthOrArrayLayers = 1;\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: srcTexture }, textureExtent);\r\n                    textureExtent.depthOrArrayLayers = layers || 1;\r\n\r\n                    // apply the preprocessing to this temp texture\r\n                    this.invertYPreMultiplyAlpha(\r\n                        srcTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        commandEncoder,\r\n                        allowGPUOptimization\r\n                    );\r\n\r\n                    // copy the temp texture to the destination texture\r\n                    commandEncoder.copyTextureToTexture({ texture: srcTexture }, textureCopyView, textureExtent);\r\n\r\n                    this._device.queue.submit([commandEncoder!.finish()]);\r\n                }\r\n            } else {\r\n                // no preprocessing: direct copy to destination texture\r\n                this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n            }\r\n        }\r\n    }\r\n\r\n    public readPixels(\r\n        texture: GPUTexture,\r\n        x: number,\r\n        y: number,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\r\n\r\n        const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n\r\n        const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\r\n\r\n        const size = bytesPerRowAligned * height;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(\r\n            size,\r\n            WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst,\r\n            undefined,\r\n            \"TempBufferForReadPixels\" + (texture.label ? \"_\" + texture.label : \"\")\r\n        );\r\n\r\n        const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n            {\r\n                texture,\r\n                mipLevel,\r\n                origin: {\r\n                    x,\r\n                    y,\r\n                    z: Math.max(faceIndex, 0),\r\n                },\r\n            },\r\n            {\r\n                buffer: gpuBuffer,\r\n                offset: 0,\r\n                bytesPerRow: bytesPerRowAligned,\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n        return this._bufferManager.readDataFromBuffer(\r\n            gpuBuffer,\r\n            size,\r\n            width,\r\n            height,\r\n            bytesPerRow,\r\n            bytesPerRowAligned,\r\n            WebGPUTextureHelper.GetTextureTypeFromFormat(format),\r\n            0,\r\n            buffer,\r\n            true,\r\n            noDataConversion\r\n        );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    public releaseTexture(texture: InternalTexture | GPUTexture): void {\r\n        if (WebGPUTextureHelper.IsInternalTexture(texture)) {\r\n            const hardwareTexture = texture._hardwareTexture;\r\n            const irradianceTexture = texture._irradianceTexture;\r\n\r\n            // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\r\n            this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\r\n        } else {\r\n            this._deferredReleaseTextures.push([texture, null]);\r\n        }\r\n    }\r\n\r\n    public destroyDeferredTextures(): void {\r\n        for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\r\n            const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\r\n\r\n            if (hardwareTexture) {\r\n                if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {\r\n                    hardwareTexture.release();\r\n                } else {\r\n                    hardwareTexture.destroy();\r\n                }\r\n            }\r\n            irradianceTexture?.dispose();\r\n        }\r\n\r\n        this._deferredReleaseTextures.length = 0;\r\n    }\r\n}\r\n"]}