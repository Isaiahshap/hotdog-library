{"version":3,"file":"boundingInfoHelper.js","sourceRoot":"","sources":["../../../../../dev/core/src/Culling/Helper/boundingInfoHelper.ts"],"names":[],"mappings":"AAKA;;;;;;;;;;;;;;GAcG;AACH,MAAM,OAAO,kBAAkB;IAI3B;;;OAGG;IACH,YAAmB,MAAsB;QACrC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAEO,KAAK,CAAC,mBAAmB;QAC7B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,qBAAqB,EAAE;gBAC9C,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,+BAA+B,CAAC,CAAC;gBAC7D,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,2BAA2B,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACzE;iBAAM,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,yBAAyB,EAAE;gBACzD,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,mCAAmC,CAAC,CAAC;gBACjE,IAAI,CAAC,SAAS,GAAG,IAAI,MAAM,CAAC,+BAA+B,CAAC,IAAI,CAAC,OAAqB,CAAC,CAAC;aAC3F;iBAAM;gBACH,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC;aAC1F;SACJ;IACL,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,YAAY,CAAC,MAAqC;QAC3D,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACjC,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,oBAAoB,CAAC,MAAqC;QACnE,MAAM,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACjC,OAAO,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;IACxD,CAAC;IAED;;;OAGG;IACI,YAAY;QACf,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE,CAAC;IACrC,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,sBAAsB;QAC/B,OAAO,IAAI,CAAC,SAAS,CAAC,4BAA4B,EAAE,CAAC;IACzD,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;IAC7B,CAAC;CACJ","sourcesContent":["import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport type { ThinEngine } from \"core/Engines\";\r\n\r\n/**\r\n * Utility class to help with bounding info management\r\n * Warning: using the BoundingInfoHelper class may be slower than executing calculations on the CPU!\r\n * This will happen if there are a lot of meshes / few vertices (like with the BrainStem model)\r\n * The BoundingInfoHelper will perform better if there are few meshes / a lot of vertices\r\n * #BCNJD4#56 =\\> does not use the BoundingInfoHelper class, performs calculations on the CPU\r\n * #BCNJD4#55 =\\> same as #56 but use the BoundingInfoHelper class\r\n * #BCNJD4#40 =\\> example with bones and morphs (webGL2)\r\n * #BCNJD4#42 =\\> example with bones and morphs (webGPU)\r\n * #HPV2TZ#475 =\\> only morph (webGL2)\r\n * #HPV2TZ#476 =\\> only morph (webGPU)\r\n * #B8B8Z2#51 =\\> Large scale test (CPU) =\\> for each mesh, this test calculates a bounding box which is the union of the bounding boxes of all the frames in a given animation\r\n * #B8B8Z2#49 =\\> Large scale test (webGL2)\r\n * #B8B8Z2#50 =\\> Large scale test (webGPU)\r\n */\r\nexport class BoundingInfoHelper {\r\n    private _platform: IBoundingInfoHelperPlatform;\r\n    private _engine: AbstractEngine;\r\n\r\n    /**\r\n     * Creates a new BoundingInfoHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    public constructor(engine: AbstractEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    private async _initializePlatform() {\r\n        if (!this._platform) {\r\n            if (this._engine.getCaps().supportComputeShaders) {\r\n                const module = await import(\"./computeShaderBoundingHelper\");\r\n                this._platform = new module.ComputeShaderBoundingHelper(this._engine);\r\n            } else if (this._engine.getCaps().supportTransformFeedbacks) {\r\n                const module = await import(\"./transformFeedbackBoundingHelper\");\r\n                this._platform = new module.TransformFeedbackBoundingHelper(this._engine as ThinEngine);\r\n            } else {\r\n                throw new Error(\"Your engine does not support Compute Shaders or Transform Feedbacks\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the bounding info of a mesh / array of meshes using shaders\r\n     * @param target defines the mesh(es) to update\r\n     * @returns a promise that resolves when the bounding info is/are computed\r\n     */\r\n    public async computeAsync(target: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        await this._initializePlatform();\r\n        return this._platform.processAsync(target);\r\n    }\r\n\r\n    /**\r\n     * Register a mesh / array of meshes to be processed per batch\r\n     * This method must be called before calling batchProcess (which can be called several times) and batchFetchResultsAsync\r\n     * @param target defines the mesh(es) to be processed per batch\r\n     * @returns a promise that resolves when the initialization is done\r\n     */\r\n    public async batchInitializeAsync(target: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        await this._initializePlatform();\r\n        return this._platform.registerMeshListAsync(target);\r\n    }\r\n\r\n    /**\r\n     * Processes meshes registered with batchRegisterAsync\r\n     * If called multiple times, the second, third, etc calls will perform a union of the bounding boxes calculated in the previous calls\r\n     */\r\n    public batchProcess(): void {\r\n        this._platform.processMeshList();\r\n    }\r\n\r\n    /**\r\n     * Update the bounding info of the meshes registered with batchRegisterAsync, after batchProcess has been called once or several times\r\n     * @returns a promise that resolves when the bounding info is/are computed\r\n     */\r\n    public async batchFetchResultsAsync(): Promise<void> {\r\n        return this._platform.fetchResultsForMeshListAsync();\r\n    }\r\n\r\n    /**\r\n     * Dispose and release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._platform.dispose();\r\n    }\r\n}\r\n"]}