{"version":3,"file":"transformFeedbackBoundingHelper.js","sourceRoot":"","sources":["../../../../../dev/core/src/Culling/Helper/transformFeedbackBoundingHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Effect } from \"core/Materials/effect\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { VertexBuffer, Buffer } from \"core/Buffers/buffer\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareAttributesForBakedVertexAnimation } from \"core/Materials/materialHelper.functions\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { IBoundingInfoHelperPlatform } from \"./IBoundingInfoHelperPlatform\";\r\nimport { extractMinAndMax } from \"core/Maths/math.functions\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nimport \"../../Shaders/gpuTransform.vertex\";\r\nimport \"../../Shaders/gpuTransform.fragment\";\r\n\r\n/** @internal */\r\nexport class TransformFeedbackBoundingHelper implements IBoundingInfoHelperPlatform {\r\n    private static _Min = new Vector3();\r\n    private static _Max = new Vector3();\r\n\r\n    private _engine: Nullable<ThinEngine>;\r\n    private _buffers: { [key: number]: Buffer } = {};\r\n    private _effects: { [key: string]: Effect } = {};\r\n    private _meshList: AbstractMesh[];\r\n    private _meshListCounter = 0;\r\n\r\n    /**\r\n     * Creates a new TransformFeedbackBoundingHelper\r\n     * @param engine defines the engine to use\r\n     */\r\n    constructor(engine: ThinEngine) {\r\n        this._engine = engine;\r\n    }\r\n\r\n    /** @internal */\r\n    public processAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshListCounter = 0;\r\n\r\n        this._processMeshList(meshes);\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _processMeshList(meshes: AbstractMesh[]) {\r\n        const parallelShaderCompile = this._engine!.getCaps().parallelShaderCompile;\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = undefined;\r\n\r\n        for (let i = 0; i < meshes.length; ++i) {\r\n            const mesh = meshes[i];\r\n            const vertexCount = mesh.getTotalVertices();\r\n\r\n            if (vertexCount === 0 || !(mesh as Mesh).getVertexBuffer || !(mesh as Mesh).getVertexBuffer(VertexBuffer.PositionKind)) {\r\n                continue;\r\n            }\r\n\r\n            // Get correct effect\r\n            let computeEffect: Effect;\r\n            let numInfluencers = 0;\r\n            const defines: string[] = [];\r\n            let uniforms: string[] = [];\r\n            const attribs = [VertexBuffer.PositionKind];\r\n            const samplers: string[] = [];\r\n\r\n            // Bones\r\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                attribs.push(VertexBuffer.MatricesIndicesKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsKind);\r\n                if (mesh.numBoneInfluencers > 4) {\r\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n                }\r\n\r\n                const skeleton = mesh.skeleton;\r\n\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n                if (skeleton.isUsingTextureForMatrices) {\r\n                    defines.push(\"#define BONETEXTURE\");\r\n\r\n                    if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                        uniforms.push(\"boneTextureWidth\");\r\n                    }\r\n\r\n                    if (samplers.indexOf(\"boneSampler\") === -1) {\r\n                        samplers.push(\"boneSampler\");\r\n                    }\r\n                } else {\r\n                    defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                    if (uniforms.indexOf(\"mBones\") === -1) {\r\n                        uniforms.push(\"mBones\");\r\n                    }\r\n                }\r\n            } else {\r\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n            }\r\n\r\n            // Morph\r\n            const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n            if (manager) {\r\n                numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\r\n                if (numInfluencers > 0) {\r\n                    defines.push(\"#define MORPHTARGETS\");\r\n                }\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                    if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                        uniforms.push(\"morphTargetTextureIndices\");\r\n                    }\r\n\r\n                    if (samplers.indexOf(\"morphTargets\") === -1) {\r\n                        samplers.push(\"morphTargets\");\r\n                    }\r\n                }\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n                for (let index = 0; index < numInfluencers; index++) {\r\n                    attribs.push(VertexBuffer.PositionKind + index);\r\n                }\r\n                if (numInfluencers > 0) {\r\n                    uniforms = uniforms.slice();\r\n                    uniforms.push(\"morphTargetInfluences\");\r\n                    uniforms.push(\"morphTargetCount\");\r\n                    uniforms.push(\"morphTargetTextureInfo\");\r\n                    uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n            }\r\n\r\n            // Baked Vertex Animation\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n                PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n            }\r\n\r\n            const join = defines.join(\"\\n\");\r\n            if (!this._effects[join]) {\r\n                const computeEffectOptions = {\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: [],\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: null,\r\n                    onCompiled: null,\r\n                    onError: null,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    maxSimultaneousLights: 0,\r\n                    transformFeedbackVaryings: [\"outPosition\"],\r\n                };\r\n                computeEffect = this._engine!.createEffect(\"gpuTransform\", computeEffectOptions, this._engine!);\r\n                this._effects[join] = computeEffect;\r\n            } else {\r\n                computeEffect = this._effects[join];\r\n            }\r\n\r\n            this._compute(mesh, computeEffect);\r\n        }\r\n\r\n        this._engine!.getCaps().parallelShaderCompile = parallelShaderCompile;\r\n    }\r\n\r\n    private _compute(mesh: AbstractMesh, effect: Effect): void {\r\n        const engine = this._engine as Engine;\r\n\r\n        // Buffer\r\n        let targetBuffer: Buffer;\r\n        const vertexCount = mesh.getTotalVertices();\r\n\r\n        if (!this._buffers[mesh.uniqueId]) {\r\n            const targetData = new Float32Array(vertexCount * 3);\r\n            targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\r\n            this._buffers[mesh.uniqueId] = targetBuffer;\r\n        } else {\r\n            targetBuffer = this._buffers[mesh.uniqueId];\r\n        }\r\n\r\n        // Bind\r\n        effect.getEngine().enableEffect(effect);\r\n        (mesh as Mesh)._bindDirect(effect, null, true);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        if (manager && manager.numInfluencers > 0) {\r\n            BindMorphTargetParameters(<Mesh>mesh, effect);\r\n        }\r\n\r\n        // BVA\r\n        const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            mesh.bakedVertexAnimationManager?.bind(effect, false);\r\n        }\r\n\r\n        // Update\r\n        const arrayBuffer = targetBuffer.getData()! as Float32Array;\r\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\r\n        engine.setRasterizerState(false);\r\n        engine.beginTransformFeedback(true);\r\n        engine.drawArraysType(Constants.MATERIAL_PointFillMode, 0, vertexCount);\r\n        engine.endTransformFeedback();\r\n        engine.setRasterizerState(true);\r\n        engine.readTransformFeedbackBuffer(arrayBuffer);\r\n        engine.bindTransformFeedbackBuffer(null);\r\n\r\n        // Update mesh\r\n        if (this._meshListCounter === 0) {\r\n            mesh._refreshBoundingInfo(arrayBuffer, null);\r\n        } else {\r\n            const bb = mesh.getBoundingInfo().boundingBox;\r\n            const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\r\n\r\n            TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\r\n            TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\r\n\r\n            mesh._refreshBoundingInfoDirect({ minimum: TransformFeedbackBoundingHelper._Min, maximum: TransformFeedbackBoundingHelper._Max });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public registerMeshListAsync(meshes: AbstractMesh | AbstractMesh[]): Promise<void> {\r\n        if (!Array.isArray(meshes)) {\r\n            meshes = [meshes];\r\n        }\r\n\r\n        this._meshList = meshes;\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public processMeshList(): void {\r\n        if (this._meshList.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._processMeshList(this._meshList);\r\n        this._meshListCounter++;\r\n    }\r\n\r\n    /** @internal */\r\n    public fetchResultsForMeshListAsync(): Promise<void> {\r\n        this._meshListCounter = 0;\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        for (const key in this._buffers) {\r\n            this._buffers[key].dispose();\r\n        }\r\n        this._buffers = {};\r\n        this._effects = {};\r\n        this._engine = null;\r\n    }\r\n}\r\n"]}