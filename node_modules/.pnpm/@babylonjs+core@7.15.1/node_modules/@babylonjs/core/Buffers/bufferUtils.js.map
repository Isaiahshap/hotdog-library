{"version":3,"file":"bufferUtils.js","sourceRoot":"","sources":["../../../../dev/core/src/Buffers/bufferUtils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAC;AACxC,OAAO,EAAE,MAAM,EAAE,MAAM,gBAAgB,CAAC;AAExC;;;;;;;;;;GAUG;AACH,MAAM,UAAU,aAAa,CACzB,KAAgB,EAChB,IAAY,EACZ,IAAY,EACZ,UAAkB,EAClB,UAAkB,EAClB,UAAmB,EACnB,aAAqB,EACrB,MAAoB;IAEpB,MAAM,uBAAuB,GAAG,IAAI,GAAG,YAAY,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IAC5E,MAAM,KAAK,GAAG,aAAa,GAAG,IAAI,CAAC;IAEnC,IAAI,MAAM,CAAC,MAAM,KAAK,KAAK,EAAE;QACzB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;KACjD;IAED,IAAI,IAAI,KAAK,YAAY,CAAC,KAAK,IAAI,UAAU,KAAK,uBAAuB,EAAE;QACvE,YAAY,CAAC,OAAO,CAAC,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;QAC9H,OAAO;KACV;IAED,IAAI,KAAK,YAAY,KAAK,EAAE;QACxB,MAAM,MAAM,GAAG,UAAU,GAAG,CAAC,CAAC;QAC9B,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;KAC7B;SAAM,IAAI,KAAK,YAAY,WAAW,EAAE;QACrC,MAAM,SAAS,GAAG,IAAI,YAAY,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAC7D,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;KACzB;SAAM;QACH,MAAM,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;QAE7C,2BAA2B;QAC3B,MAAM,SAAS,GAAG,MAAM,GAAG,CAAC,CAAC;QAC7B,IAAI,SAAS,EAAE;YACX,MAAM,CAAC,IAAI,CAAC,wCAAwC,CAAC,CAAC;YACtD,kDAAkD;YAClD,MAAM,CAAC,GAAG,CAAC,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAC7E,OAAO;SACV;QAED,MAAM,SAAS,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAChE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;KACzB;AACL,CAAC","sourcesContent":["import type { DataArray } from \"../types\";\r\nimport { VertexBuffer } from \"./buffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Copies the given data array to the given float array.\r\n * @param input the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param output the output float array\r\n */\r\nexport function CopyFloatData(\r\n    input: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    output: Float32Array\r\n): void {\r\n    const tightlyPackedByteStride = size * VertexBuffer.GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (output.length !== count) {\r\n        throw new Error(\"Output length is not valid\");\r\n    }\r\n\r\n    if (type !== VertexBuffer.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        VertexBuffer.ForEach(input, byteOffset, byteStride, size, type, count, normalized, (value, index) => (output[index] = value));\r\n        return;\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n        const offset = byteOffset / 4;\r\n        output.set(input, offset);\r\n    } else if (input instanceof ArrayBuffer) {\r\n        const floatData = new Float32Array(input, byteOffset, count);\r\n        output.set(floatData);\r\n    } else {\r\n        const offset = input.byteOffset + byteOffset;\r\n\r\n        // Protect against bad data\r\n        const remainder = offset % 4;\r\n        if (remainder) {\r\n            Logger.Warn(\"CopyFloatData: copied misaligned data.\");\r\n            // If not aligned, copy the data to aligned buffer\r\n            output.set(new Float32Array(input.buffer.slice(offset, offset + count * 4)));\r\n            return;\r\n        }\r\n\r\n        const floatData = new Float32Array(input.buffer, offset, count);\r\n        output.set(floatData);\r\n    }\r\n}\r\n"]}